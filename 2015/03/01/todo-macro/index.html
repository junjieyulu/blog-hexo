<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 实现一个TODO宏 · sunnyxx的技术博客</title><meta name="description" content="实现一个TODO宏 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">实现一个TODO宏</h1><div class="post-time">2015年3月1日</div><div class="post-content"><p>实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg" width="500"><br><img src="http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg" width="500"></p>
<p>下面一步步来实现这个宏。</p>
<hr>
<h1 id="Let’s-do-it"><a href="#Let’s-do-it" class="headerlink" title="Let’s do it"></a>Let’s do it</h1><p>手动让编译器报警（报错）可以用以下几个方法：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#warning sunnyxx</span></span><br><span class="line"><span class="meta">#error sunnyxx</span></span><br><span class="line"><span class="meta">#pragma message <span class="meta-string">"sunnyxx"</span></span></span><br><span class="line"><span class="meta">#pragma GCC warning <span class="meta-string">"sunnyxx"</span></span></span><br><span class="line"><span class="meta">#pragma GCC error <span class="meta-string">"sunnyxx"</span></span></span><br></pre></td></tr></table></figure>
<p>但我们知道，带<code>#</code>的预处理指令是无法被<code>#define</code>的。好在<strong>C99</strong>提供了一个<code>_Pragma</code>运算符可以把部分<code>#pragma</code>指令字符串化：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma message <span class="meta-string">"sunnyxx"</span></span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">_Pragma(<span class="string">"message \"sunnyxx\""</span>) <span class="comment">// 需要注意双引号的转义</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">_Pragma(<span class="string">"message(\"sunnyxx\")"</span>) <span class="comment">// 需要注意双引号的转义</span></span><br></pre></td></tr></table></figure>
<p>利用这个特性，我们就可以将warning定义成宏</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SOME_WARNING _Pragma(<span class="meta-string">"message(\"</span>报告大王！\<span class="meta-string">")"</span>)</span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    SOME_WARNING <span class="comment">// [!]报告大王！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br></pre></td></tr></table></figure>
<p>个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：<code>STRINGIFY(S)</code> 将入参转化成字符串，省去了<code>_Pragma</code>中全串加转义字符的困扰。<br>这时，一个基本功能的TODO宏就完成了，下面向其中加入<strong>额外的信息</strong>：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个已有的宏</span></span><br><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class="line"><span class="comment">// 延迟1次展开的宏</span></span><br><span class="line"><span class="meta">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class="line"><span class="comment">// 下面的宏在第一行用`\`折行</span></span><br><span class="line"><span class="meta">#define FORMATTED_MESSAGE(MSG) <span class="meta-string">"[TODO-"</span> DEFER_STRINGIFY(__COUNTER__) <span class="meta-string">"] "</span> MSG <span class="meta-string">" \n"</span>  \</span></span><br><span class="line">    DEFER_STRINGIFY(__FILE__) <span class="string">" line "</span> DEFER_STRINGIFY(__LINE__)</span><br></pre></td></tr></table></figure>
<p>其中涉及到的知识：  </p>
<ul>
<li>两个常量字符串可以拼接成一个整串 “123””456” =&gt; “123456”</li>
<li>使用到3个<strong>预定义宏</strong>，<code>__COUNTER__</code>宏展开次数的计数器，全局唯一；<code>__FILE__</code>当前文件完整目录字符串；<code>__LINE__</code>在当前文件第几行</li>
<li>在字符串中<strong>预定义宏</strong>应延时展开，如果将上面的<code>DEFER_STRINGIFY</code>换成<code>STRINGIFY</code>的话，如<code>__LINE__</code>就不能被正确展开成行数，而是成了一个常量字符串<code>&quot;__LINE__&quot;</code></li>
<li>为了美化，warning message中可以使用<code>\n</code>换行</li>
</ul>
<p>于是，使用<code>FORMATTED_MESSAGE(MSG)</code>宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  </p>
<hr>
<p>其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加<code>@</code>的形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>将最终的宏定义前面加上上面的宏后，使用时就可以加<code>@</code>前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）</p>
<hr>
<h1 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class="line"><span class="meta">#define FORMATTED_MESSAGE(MSG) <span class="meta-string">"[TODO-"</span> DEFER_STRINGIFY(__COUNTER__) <span class="meta-string">"] "</span> MSG <span class="meta-string">" \n"</span> \</span></span><br><span class="line">DEFER_STRINGIFY(__FILE__) <span class="string">" line "</span> DEFER_STRINGIFY(__LINE__)</span><br><span class="line"><span class="meta">#define KEYWORDIFY try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 最终使用下面的宏</span></span><br><span class="line"><span class="meta">#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h1><p>除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写<code>// TODO: ...</code>的注释，让Xcode导航栏中也出现这个TODO了：<br><img src="http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg" width="300"><br>但很可惜没有找到一个可行的方法，欢迎一起解决。<br>Xcode插件<a href="https://github.com/trawor/XToDo" target="_blank" rel="external">《XTodo》</a>也是利用这个特性，可以尝试下。</p>
<p>如果需要一个产生error的宏，将这里替换成这样就好了：<code>_Pragma(STRINGIFY(GCC error(MSG)))</code></p>
<p>同时，上面的代码在<a href="https://github.com/sunnyxx/TodoMacro" target="_blank" rel="external">《github上》</a>可以找到。也欢迎关注微博<a href="http://weibo.com/u/1364395395" target="_blank" rel="external">@我就叫Sunny怎么了</a>一起交流。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="external">http://clang.llvm.org/docs/UsersManual.html</a><br><a href="https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/03/09/notification-once/" class="prev">上一篇</a><a href="/2015/01/17/self-in-arc/" class="next">下一篇</a></div><div data-thread-key="2015/03/01/todo-macro/" data-title="实现一个TODO宏" data-url="http://blog.sunnyxx.com/2015/03/01/todo-macro/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>