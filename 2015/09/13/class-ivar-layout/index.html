<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C Class Ivar Layout 探索 · sunnyxx的技术博客</title><meta name="description" content="Objective-C Class Ivar Layout 探索 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C Class Ivar Layout 探索</h1><div class="post-time">2015年9月13日</div><div class="post-content"><p>这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> _gayFriend; <span class="comment">// 无修饰符的对象默认会加 __strong</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> _girlFriend;</span><br><span class="line">    __unsafe_unretained <span class="keyword">id</span> _company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  </p>
<p>那么问题来了，假如这个类是动态生成的：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">"Sark"</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(class, <span class="string">"_gayFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(class, <span class="string">"_girlFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(class, <span class="string">"_company"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>
<p>该如何像上面一样来添加 ivar 的属性修饰符呢？  </p>
<p>刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout; <span class="comment">// &lt;- 记录了哪些是 strong 的 ivar</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">const</span> method_list_t * baseMethods;</span><br><span class="line">    <span class="keyword">const</span> protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout; <span class="comment">// &lt;- 记录了哪些是 weak 的 ivar</span></span><br><span class="line">    <span class="keyword">const</span> property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。</p>
<p>这两个值可以通过 runtime 提供的几个 API 来访问：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br></pre></td></tr></table></figure>
<p>但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。</p>
<p>举个例子说明，若类定义为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012000</strong></p>
<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x1200</strong></p>
<p>一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：</p>
<ol>
<li>前两位 <strong>01</strong> 表示有 0 个非 strong 对象和 1 个 strong 对象</li>
<li>之后两位 <strong>20</strong> 表示有 2 个非 strong 对象和 0 个 strong 对象</li>
<li>最后两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li>
</ol>
<p>同理，上面的 weakIvarLayout：</p>
<ol>
<li>前两位 <strong>12</strong> 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象</li>
<li><strong>00</strong> 结束符</li>
</ol>
<p>这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.</p>
<p>做个练习，若类定义为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bar</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __unsafe_unretained <span class="keyword">id</span> ivar2;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012100</strong></p>
<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x01211000</strong></p>
<p>于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class class = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">"Sark"</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(class, <span class="string">"_gayFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(class, <span class="string">"_girlFriend"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(class, <span class="string">"_company"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), @encode(<span class="keyword">id</span>));</span><br><span class="line">class_setIvarLayout(class, (<span class="keyword">const</span> uint8_t *)<span class="string">"\x01\x12"</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(class, (<span class="keyword">const</span> uint8_t *)<span class="string">"\x11\x10"</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">objc_registerClassPair(class);</span><br></pre></td></tr></table></figure>
<p>本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> fixup_class_arc(Class class) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Class isa;</span><br><span class="line">        Class superclass;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> *_buckets;</span><br><span class="line"><span class="meta">#if __LP64__</span></span><br><span class="line">            uint32_t _mask;</span><br><span class="line">            uint32_t _occupied;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">            uint16_t _mask;</span><br><span class="line">            uint16_t _occupied;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        &#125; cache;</span><br><span class="line">        uintptr_t bits;</span><br><span class="line">    &#125; *objcClass = (__bridge <span class="keyword">typeof</span>(objcClass))class;</span><br><span class="line"><span class="meta">#if !__LP64__</span></span><br><span class="line"><span class="meta">#define FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">        uint32_t version;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            uint32_t flags;</span><br><span class="line">        &#125; *ro;</span><br><span class="line">    &#125; *objcRWClass = (<span class="keyword">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class="line"><span class="meta">#define RO_IS_ARR 1<span class="meta-string">&lt;&lt;7    </span><br><span class="line">    objcRWClass-&gt;</span>ro-&gt;flags |= RO_IS_ARR;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> sark = [class new];</span><br><span class="line">Ivar weakIvar = class_getInstanceVariable(class, <span class="string">"_girlFriend"</span>);</span><br><span class="line">Ivar strongIvar = class_getInstanceVariable(class, <span class="string">"_gayFriend"</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> girl = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> boy = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    object_setIvar(sark, weakIvar, girl);</span><br><span class="line">    object_setIvar(sark, strongIvar, boy);</span><br><span class="line">&#125; <span class="comment">// ARC 在这里会释放大括号内的 girl，boy</span></span><br><span class="line"><span class="comment">// 输出：weakIvar 为 nil，strongIvar 有值</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));</span><br></pre></td></tr></table></figure>
<p>Done.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/12/19/self-manager-pattern-in-ios/" class="prev">上一篇</a><a href="/2015/07/04/ios-interview/" class="next">下一篇</a></div><div data-thread-key="2015/09/13/class-ivar-layout/" data-title="Objective-C Class Ivar Layout 探索" data-url="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>