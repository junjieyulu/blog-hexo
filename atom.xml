<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunnyxx的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sunnyxx.com/"/>
  <updated>2016-04-21T16:28:14.000Z</updated>
  <id>http://blog.sunnyxx.com/</id>
  
  <author>
    <name>sunnyxx</name>
    <email>sunyuan1713@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>巧用 Class Extension 分离接口依赖</title>
    <link href="http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/"/>
    <id>http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/</id>
    <published>2016-04-22T12:33:41.000Z</published>
    <updated>2016-04-21T16:28:14.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;Class Extension&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 是我们经常使用的 Objective-C 语法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Class Extension&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; ()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Category&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Gay&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还记得最开始学习 Objective-C 时，并没有支持 Class Extension，当时只能凑活的用个 Private 的 Category 充当，需要添加私有成员变量时那叫个痛苦，直到大概四年前的 WWDC 终于宣布添加上了 Class Extension 的语法，当时底下的开发者们含泪报以了热烈掌声，它让类的封装变的更加得心用手。&lt;/p&gt;
&lt;p&gt;在类组织结构上，Category 可以用来帮助拆分功能，让一个大型的类分治管理：（类似 &lt;code&gt;NSString.h&lt;/code&gt; ）&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSSting&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Gay&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)behaviorLikeGay;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark+Work.h &amp;lt;----- 也可拆分成多个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Work&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)writeObjectiveC;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过有两个设计原则必须要遵守：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Category 的实现可以依赖主类，但主类一定不依赖 Category，也就是说移除任何一个 Category 的代码不会对主类产生任何影响。&lt;/li&gt;
&lt;li&gt;Category 可以直接使用主类已有的私有成员变量，但不应该为实现 Category 而往主类中添加成员变量，考虑在 Category 的实现中使用 &lt;code&gt;objc association&lt;/code&gt; 来达到相同效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所以 Category 一定是简单插拔的，就像买个外接键盘来扩展在 MacBook 上的写码能力，但当拔了键盘，MacBook 的运行不会受到任何影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 Class Extension 和 Category 在语言机制上有着很大差别：Class Extension 在编译期就会将定义的 Ivar、属性、方法等直接合入主类，而 Category 在程序启动 Runtime Loading 时才会将属性（没 Ivar）和方法合入主类。但有意思的是，两者在在语法解析层面却只有细微的差别，可以尝试用 &lt;code&gt;clang&lt;/code&gt; 命令查看一个文件的 &lt;code&gt;AST&lt;/code&gt;（抽象语法树）&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ clang -Xclang -ast-dump -fsyntax-only main.m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;生成 AST 是 Clang 其中一个比较重要的职责，像 Xcode 的代码补全、语法检查、代码风格规范都是在这一层做的；如果像我一样无聊，也可以玩玩 &lt;a href=&quot;http://clang.llvm.org/doxygen/group__CINDEX.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libclang&lt;/a&gt;，一个 C 语言 Clang API，输入代码，就能将其解析成语法树，通过遍历 AST，可以取得每个 Decl 和 Token 的信息和所处的源码行数和位置，大到类定义，小到一个逗号一个分号都能完全掌控，非常有助于理解编译器如何处理源码；有了 libclang，定义些规则就能实现个简单的 Linter 啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的命令会在控制台中打印出一堆花花绿绿的语法树结构，挑出我们关注的信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-ObjCCategoryDecl &amp;lt;line:7:1, line:9:2&amp;gt; line:7:12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |-ObjCInterface &amp;apos;Sark&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-ObjCCategoryDecl &amp;lt;line:15:1, line:17:2&amp;gt; line:15:12 Gay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |-ObjCInterface &amp;apos;Sark&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，Class Extension 和 Category 在 AST 中的表示都是 &lt;code&gt;ObjCCategoryDecl&lt;/code&gt;，只是有无名字的区别，也可以说 &lt;strong&gt;Class Extension 是匿名的 Category&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;既然 Category 可以有 N 个，Class Extension 也可以有，且它不限于写在 &lt;code&gt;.m&lt;/code&gt; 中，只要在 &lt;code&gt;@implementation&lt;/code&gt; 前定义就可以，我们可以利用这个性质，将 Header 中的声明按功能归类：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里定义了很多基本属性和方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; () // &lt;span class=&quot;title&quot;&gt;Gay&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *gayFriend; &lt;span class=&quot;comment&quot;&gt;// 属性 √&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)behaviorLikeGay;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; () // &lt;span class=&quot;title&quot;&gt;Work&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *company; &lt;span class=&quot;comment&quot;&gt;// 属性 √&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)writeObjectiveC;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;与 Category 不同，Class Extension 的分组形式并没有破坏 “一个主类” 的 &lt;del&gt;基本外交原则&lt;/del&gt; 基本结构，还可以把属性（ Ivar ）也放心丢进来。&lt;/p&gt;
&lt;p&gt;— 正题分割线 —&lt;/p&gt;
&lt;p&gt;除此之外，Class Extension 还能巧妙的解决一个接口暴露问题，若有下面的声明：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.framework/Sark.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *creditCardPassword; &lt;span class=&quot;comment&quot;&gt;// secret!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.framework/PrivateSarkWife.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PrivateSarkWife&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)robAllMoneyFromCreditCardOfSark:(Sark *)sark; &lt;span class=&quot;comment&quot;&gt;// needs password!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设 &lt;code&gt;Sark.h&lt;/code&gt; 是 &lt;code&gt;Sark.framework&lt;/code&gt; 唯一暴露的 Header，而 framework 中的一个私有类需要获取这个公共类的某个属性（或方法）该怎么办？上面的 &lt;code&gt;creditCardPassword&lt;/code&gt; 属性需要一个对外不可见而对内可见的地方声明，这时候可以利用 Class Extension：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark+Internal.h &amp;lt;--- new&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; :()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *creditCardPassword;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sark.m&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;Sark.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;Sark+Internal.h&quot;&lt;/span&gt; // &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;--- new&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;将对公业务和对私业务用 Class Extension 的形式拆到两个 Header 中&lt;/strong&gt;，这样私有类对私有属性的依赖就被成功隔离开了：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// PrivateSarkWife.m&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;string&quot;&gt;&quot;PrivateSarkWife.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;string&quot;&gt;&quot;Sark+Internal.h&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// &amp;lt;--- 私有依赖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation PrivateSarkWife&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)robAllMoneyFromCreditCardOfSark:(Sark *)sark &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *password = sark.creditCardPassword; &lt;span class=&quot;comment&quot;&gt;// oh yeah!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Done.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Class Extension&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 是我们经常使用的 Objective-C 语法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 开发中的 Self-Manager 模式</title>
    <link href="http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/"/>
    <id>http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/</id>
    <published>2015-12-19T03:53:06.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;Self-Manager&lt;/code&gt; 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”&lt;/p&gt;
&lt;p&gt;最近，这个思路被我们当做了一种设计模式，即&lt;strong&gt;赋予一个 Widget 更大的权利，让其自己负责自己的事件。&lt;/strong&gt;&lt;br&gt;举个简单的栗子，这种负责展示头像的视图：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg&quot; width=&quot;320&quot;&gt;&lt;br&gt;它的职责包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过传入的 URL，加载并展示头像图片&lt;/li&gt;
&lt;li&gt;显示一些附属信息，比如大V的标志&lt;/li&gt;
&lt;li&gt;将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是乎这个 Widget 的 API 可以长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDAvatarView&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 假设 VIPInfo 是某个 Entity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)configureWithAvatarURL:(&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *)URL VIPInfo:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)info tapped:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;))block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。&lt;/li&gt;
&lt;li&gt;这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 &lt;strong&gt;“Middle Man”&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 &lt;code&gt;Self-Managed&lt;/code&gt;，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDAvatarView&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;FDAvatarViewSelfManager&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selfManagedConfigureWithAvatarURL:(&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *)URL VIPInfo:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)info uid:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)uid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现时最好要调用 View 主类提供的 API：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDAvatarView&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;FDAvatarViewSelfManager&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 为后一个页面的创建增加了个 UID 参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selfManagedConfigureWithAvatarURL:(&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *)URL VIPInfo:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)info &lt;span class=&quot;built_in&quot;&gt;UID&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;UID&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; configureWithAvatarURL:URL VIPInfo:info tapped:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// 假设 App 结构是 Root -&amp;gt; TabBar -&amp;gt; Navigation -&amp;gt; ViewController&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UITabBarController&lt;/span&gt; *tabBarControler = (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt;.sharedApplication.delegate.window.rootViewController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *navigationController = tabBarControler.selectedViewController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建用户信息 View Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWith&lt;span class=&quot;built_in&quot;&gt;UID&lt;/span&gt;:&lt;span class=&quot;built_in&quot;&gt;UID&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [navigationController pushViewController:profileViewController animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。&lt;br&gt;这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。&lt;/p&gt;
&lt;p&gt;接下来再来个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个点赞的按钮功能上有几个职责：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示已有的点赞数&lt;/li&gt;
&lt;li&gt;点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。&lt;/li&gt;
&lt;li&gt;若已经点赞，点击执行反向操作&lt;/li&gt;
&lt;li&gt;若网络请求发送失败，则回退成点击前的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个控件的 API 可以设计成这样：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDLikeButton&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIButton&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)configureLikeStatus:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)likeOrNot count:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)count animated:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDLikeButton&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;FDLikeButtonSelfManager&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selfManagedConfigureWithLikeStatus:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)likeOrNot count:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;伪代码的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FDLikeButton&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;FDLikeButtonSelfManager&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selfManagedConfigureWithLikeStatus:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)likeOrNot count:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)count &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; configureLikeStatus:likeOrNot count:count animated:&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; addTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(likeButtonTapped:) forControlEvents:&lt;span class=&quot;built_in&quot;&gt;UIControlEventTouchUpInside&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)likeButtonTapped:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// +1 or -1 with animation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Network request ^(NSError *error) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//     if (error) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//         rollback&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//     &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。&lt;/p&gt;
&lt;p&gt;程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让一大坨恶心的代码变成几小坨不那么恶心的代码。&lt;/li&gt;
&lt;li&gt;让恶心的代码只在一个地方恶心。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Self-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Self-Manager&lt;/code&gt; 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”&lt;/p&gt;
&lt;p&gt;最近，这个思路被我们当做了一种设计模式，即&lt;strong&gt;赋予一个 Wid
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Class Ivar Layout 探索</title>
    <link href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/"/>
    <id>http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/</id>
    <published>2015-09-13T11:04:37.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; _gayFriend; &lt;span class=&quot;comment&quot;&gt;// 无修饰符的对象默认会加 __strong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; _girlFriend;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __unsafe_unretained &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; _company;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。  &lt;/p&gt;
&lt;p&gt;那么问题来了，假如这个类是动态生成的：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class class = objc_allocateClassPair(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;.class, &lt;span class=&quot;string&quot;&gt;&quot;Sark&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_gayFriend&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_girlFriend&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_company&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_registerClassPair(class);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该如何像上面一样来添加 ivar 的属性修饰符呢？  &lt;/p&gt;
&lt;p&gt;刨根问底了一下，发现 ivar 的修饰信息存放在了 Class 的 Ivar Layout 中：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; class_ro_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t instanceStart;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t instanceSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t * ivarLayout; &lt;span class=&quot;comment&quot;&gt;// &amp;lt;- 记录了哪些是 strong 的 ivar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; method_list_t * baseMethods;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; protocol_list_t * baseProtocols;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ivar_list_t * ivars;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t * weakIvarLayout; &lt;span class=&quot;comment&quot;&gt;// &amp;lt;- 记录了哪些是 weak 的 ivar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; property_list_t *baseProperties;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。&lt;/p&gt;
&lt;p&gt;这两个值可以通过 runtime 提供的几个 API 来访问：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *class_getIvarLayout(Class cls)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *class_getWeakIvarLayout(Class cls)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; class_setIvarLayout(Class cls, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *layout)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; class_setWeakIvarLayout(Class cls, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *layout)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但我们几乎没可能用到这几个 API，IvarLayout 的值由 runtime 确定，没必要关心它的存在，但为了解决上述问题，我们试着破解了 IvarLayout 的编码方式。&lt;/p&gt;
&lt;p&gt;举个例子说明，若类定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;则储存 strong ivar 的 ivarLayout 的值为 &lt;strong&gt;0x012000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;储存 weak ivar 的 weakIvarLayout 的值为 &lt;strong&gt;0x1200&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前两位 &lt;strong&gt;01&lt;/strong&gt; 表示有 0 个非 strong 对象和 1 个 strong 对象&lt;/li&gt;
&lt;li&gt;之后两位 &lt;strong&gt;20&lt;/strong&gt; 表示有 2 个非 strong 对象和 0 个 strong 对象&lt;/li&gt;
&lt;li&gt;最后两位 &lt;strong&gt;00&lt;/strong&gt; 为结束符，就像 cstring 的 &lt;strong&gt;\0&lt;/strong&gt; 一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同理，上面的 weakIvarLayout：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前两位 &lt;strong&gt;12&lt;/strong&gt; 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;00&lt;/strong&gt; 结束符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.&lt;/p&gt;
&lt;p&gt;做个练习，若类定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Bar&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __unsafe_unretained &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ivar4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;则储存 strong ivar 的 ivarLayout 的值为 &lt;strong&gt;0x012100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;储存 weak ivar 的 weakIvarLayout 的值为 &lt;strong&gt;0x01211000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是乎将 class 的创建代码增加了两个 ivarLayout 值的设置：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class class = objc_allocateClassPair(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;.class, &lt;span class=&quot;string&quot;&gt;&quot;Sark&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_gayFriend&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_girlFriend&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(class, &lt;span class=&quot;string&quot;&gt;&quot;_company&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;), log2(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)), @encode(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_setIvarLayout(class, (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *)&lt;span class=&quot;string&quot;&gt;&quot;\x01\x12&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// &amp;lt;--- new&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_setWeakIvarLayout(class, (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *)&lt;span class=&quot;string&quot;&gt;&quot;\x11\x10&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// &amp;lt;--- new&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_registerClassPair(class);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;本以为解决了这个问题，但是 runtime 继续打脸，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 &lt;strong&gt;-fobjc-arc&lt;/strong&gt; flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; fixup_class_arc(Class class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class superclass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *_buckets;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uint32_t _mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uint32_t _occupied;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; cache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uintptr_t bits;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; *objcClass = (__bridge &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(objcClass))class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#if !__LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define FAST_DATA_MASK 0xfffffffcUL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define FAST_DATA_MASK 0x00007ffffffffff8UL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uint32_t flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uint32_t version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uint32_t flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; *ro;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; *objcRWClass = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(objcRWClass))(objcClass-&amp;gt;bits &amp;amp; FAST_DATA_MASK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define RO_IS_ARR 1&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;&amp;lt;7    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objcRWClass-&amp;gt;&lt;/span&gt;ro-&amp;gt;flags |= RO_IS_ARR;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把这个 fixup 放在 &lt;code&gt;objc_registerClassPair(class);&lt;/code&gt; 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了，可以测试一下：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; sark = [class new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ivar weakIvar = class_getInstanceVariable(class, &lt;span class=&quot;string&quot;&gt;&quot;_girlFriend&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ivar strongIvar = class_getInstanceVariable(class, &lt;span class=&quot;string&quot;&gt;&quot;_gayFriend&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; girl = [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; boy = [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    object_setIvar(sark, weakIvar, girl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    object_setIvar(sark, strongIvar, boy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// ARC 在这里会释放大括号内的 girl，boy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出：weakIvar 为 nil，strongIvar 有值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@, %@&quot;&lt;/span&gt;, object_getIvar(sark, weakIvar), object_getIvar(sark, strongIvar));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Done.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次探索源于一个朋友问的问题，当我们定义一个类的实例变量的时候，可以指定其修饰符：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
    
    </summary>
    
    
      <category term="objc刨根问底" scheme="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>招聘一个靠谱的 iOS</title>
    <link href="http://blog.sunnyxx.com/2015/07/04/ios-interview/"/>
    <id>http://blog.sunnyxx.com/2015/07/04/ios-interview/</id>
    <published>2015-07-04T00:34:01.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。&lt;/p&gt;
&lt;h2 id=&quot;一个靠谱的简历&quot;&gt;&lt;a href=&quot;#一个靠谱的简历&quot; class=&quot;headerlink&quot; title=&quot;一个靠谱的简历&quot;&gt;&lt;/a&gt;一个靠谱的简历&lt;/h2&gt;&lt;p&gt;简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 &lt;strong&gt;iOS&lt;/strong&gt; 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：  &lt;/p&gt;
&lt;p&gt;iPhone -&amp;gt; IPHONE IPhone&lt;br&gt;Xcode -&amp;gt; XCode xcode&lt;br&gt;Objective-C -&amp;gt; Object-C&lt;br&gt;JSON -&amp;gt; Json&lt;br&gt;HTTP -&amp;gt; Http&lt;/p&gt;
&lt;p&gt;还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -&lt;/p&gt;
&lt;h2 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h2&gt;&lt;p&gt;别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。&lt;br&gt;面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。&lt;/p&gt;
&lt;h3 id=&quot;关于算法&quot;&gt;&lt;a href=&quot;#关于算法&quot; class=&quot;headerlink&quot; title=&quot;关于算法&quot;&gt;&lt;/a&gt;关于算法&lt;/h3&gt;&lt;p&gt;我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。&lt;/p&gt;
&lt;h3 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h3&gt;&lt;p&gt;这是一个重点考察项，曾经在微博上发过一个风格纠错题：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀&lt;/p&gt;
&lt;h2 id=&quot;一个区分度很大的面试题&quot;&gt;&lt;a href=&quot;#一个区分度很大的面试题&quot; class=&quot;headerlink&quot; title=&quot;一个区分度很大的面试题&quot;&gt;&lt;/a&gt;一个区分度很大的面试题&lt;/h2&gt;&lt;p&gt;考察一个面试者基础咋样，基本上问一个 @property 就够了：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@property 后面可以有哪些修饰符？&lt;/li&gt;
&lt;li&gt;什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/li&gt;
&lt;li&gt;怎么用 copy 关键字？&lt;/li&gt;
&lt;li&gt;这个写法会出什么问题： &lt;code&gt;@property (copy) NSMutableArray *array;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的&lt;/li&gt;
&lt;li&gt;@protocol 和 category 中如何使用 @property&lt;/li&gt;
&lt;li&gt;runtime 如何实现 weak 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Checklist&quot;&gt;&lt;a href=&quot;#Checklist&quot; class=&quot;headerlink&quot; title=&quot;Checklist&quot;&gt;&lt;/a&gt;Checklist&lt;/h2&gt;&lt;p&gt;总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：&lt;/p&gt;
&lt;p&gt;[※]@property中有哪些属性关键字？&lt;br&gt;[※]weak属性需要在dealloc中置nil么？&lt;br&gt;[※※]@synthesize和@dynamic分别有什么作用？&lt;br&gt;[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&lt;br&gt;[※※※]用@property声明的&lt;code&gt;NSString&lt;/code&gt;（或&lt;code&gt;NSArray&lt;/code&gt;，&lt;code&gt;NSDictionary&lt;/code&gt;）经常使用&lt;code&gt;copy&lt;/code&gt;关键字，为什么？如果改用&lt;code&gt;strong&lt;/code&gt;关键字，可能造成什么问题？&lt;br&gt;[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？&lt;br&gt;[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？  &lt;/p&gt;
&lt;p&gt;[※※]objc中向一个nil对象发送消息将会发生什么？&lt;br&gt;[※※※]objc中向一个对象发送消息&lt;code&gt;[obj foo]&lt;/code&gt;和&lt;code&gt;objc_msgSend()&lt;/code&gt;函数之间有什么关系？&lt;br&gt;[※※※]什么时候会报&lt;code&gt;unrecognized selector&lt;/code&gt;的异常？&lt;br&gt;[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）&lt;br&gt;[※※※※]一个objc对象的&lt;code&gt;isa&lt;/code&gt;的指针指向什么？有什么作用？&lt;br&gt;[※※※※]下面的代码输出什么？    &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Son&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Father&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）&lt;br&gt;[※※※※]使用&lt;code&gt;runtime Associate&lt;/code&gt;方法关联的对象，需要在主对象dealloc的时候释放么？&lt;br&gt;[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？&lt;br&gt;[※※※※※]&lt;code&gt;_objc_msgForward&lt;/code&gt;函数是做什么的，直接调用它将会发生什么？&lt;br&gt;[※※※※※]runtime如何实现weak变量的自动置nil？&lt;br&gt;[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？  &lt;/p&gt;
&lt;p&gt;[※※※]runloop和线程有什么关系？&lt;br&gt;[※※※]runloop的mode作用是什么？&lt;br&gt;[※※※※]以&lt;code&gt;+ scheduledTimerWithTimeInterval...&lt;/code&gt;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？&lt;br&gt;[※※※※※]猜想runloop内部是如何实现的？  &lt;/p&gt;
&lt;p&gt;[※]objc使用什么机制管理对象内存？&lt;br&gt;[※※※※]ARC通过什么方式帮助开发者管理内存？&lt;br&gt;[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）&lt;br&gt;[※※※※]BAD_ACCESS在什么情况下出现？&lt;br&gt;[※※※※※]苹果是如何实现autoreleasepool的？   &lt;/p&gt;
&lt;p&gt;[※※]使用block时什么情况会发生引用循环，如何解决？&lt;br&gt;[※※]在block内如何修改block外部变量？&lt;br&gt;[※※※]使用系统的某些block api（如&lt;code&gt;UIView&lt;/code&gt;的block版本写动画时），是否也考虑引用循环问题？   &lt;/p&gt;
&lt;p&gt;[※※]GCD的队列（dispatch_queue_t）分哪两种类型？&lt;br&gt;[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;br&gt;[※※※※]dispatch_barrier_async的作用是什么？&lt;br&gt;[※※※※※]苹果为什么要废弃dispatch_get_current_queue？&lt;br&gt;[※※※※※]以下代码运行结果如何？   &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;3&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[※※]&lt;code&gt;addObserver:forKeyPath:options:context:&lt;/code&gt;各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？&lt;br&gt;[※※※]如何手动触发一个value的KVO&lt;br&gt;[※※※]若一个类有实例变量&lt;code&gt;NSString *_foo&lt;/code&gt;，调用&lt;code&gt;setValue:forKey:&lt;/code&gt;时，可以以&lt;code&gt;foo&lt;/code&gt;还是&lt;code&gt;_foo&lt;/code&gt;作为key？&lt;br&gt;[※※※※]KVC的&lt;code&gt;keyPath&lt;/code&gt;中的集合运算符如何使用？&lt;br&gt;[※※※※]KVC和KVO的&lt;code&gt;keyPath&lt;/code&gt;一定是属性么？&lt;br&gt;[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？&lt;br&gt;[※※※※※]apple用什么方式实现对一个对象的KVO？    &lt;/p&gt;
&lt;p&gt;[※※]IBOutlet连出来的视图属性为什么可以被设置成&lt;code&gt;weak&lt;/code&gt;?&lt;br&gt;[※※※※※]IB中&lt;code&gt;User Defined Runtime Attributes&lt;/code&gt;如何使用？   &lt;/p&gt;
&lt;p&gt;[※※※]如何调试BAD_ACCESS错误&lt;br&gt;[※※※]lldb（gdb）常用的调试命令？&lt;/p&gt;
&lt;p&gt;这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。&lt;/p&gt;
&lt;h2 id=&quot;业务能力&quot;&gt;&lt;a href=&quot;#业务能力&quot; class=&quot;headerlink&quot; title=&quot;业务能力&quot;&gt;&lt;/a&gt;业务能力&lt;/h2&gt;&lt;p&gt;毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。&lt;br&gt;要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~  &lt;/p&gt;
&lt;p&gt;程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？&lt;br&gt;架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。&lt;/p&gt;
&lt;p&gt;网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。  &lt;/p&gt;
&lt;h2 id=&quot;性格&quot;&gt;&lt;a href=&quot;#性格&quot; class=&quot;headerlink&quot; title=&quot;性格&quot;&gt;&lt;/a&gt;性格&lt;/h2&gt;&lt;p&gt;大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。&lt;/p&gt;
&lt;p&gt;招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1ets0j4fy8aj20cf0afjsp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试
    
    </summary>
    
    
      <category term="wtf" scheme="http://blog.sunnyxx.com/tags/wtf/"/>
    
  </entry>
  
  <entry>
    <title>2015 Objective-C 新特性</title>
    <link href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/"/>
    <id>http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</id>
    <published>2015-06-12T15:12:56.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次高涨起来，在羡慕创业公司的朋友们大谈 Swift 新特性的同时，也有很多像我一样工作上依然需要坚守着 Objective-C 语言的开发者们。今年的 WWDC 中介绍了几个 Objective-C 语言的新特性，还是在“与 Swift 协同工作”这种 Topic 里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nullability&lt;/li&gt;
&lt;li&gt;Lightweight Generics *&lt;/li&gt;
&lt;li&gt;__kindof&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Nullability&quot;&gt;&lt;a href=&quot;#Nullability&quot; class=&quot;headerlink&quot; title=&quot;Nullability&quot;&gt;&lt;/a&gt;Nullability&lt;/h1&gt;&lt;p&gt;然而 Nullability 并不算新特性了，从上一个版本的 llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的 Optional ，没有 Swift 中 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt; 语法糖的支持，在 Objective-C 中就显得非常啰嗦了：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, nonnull) Sark *sark;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, nullable) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *friends;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)friendWithName:(nonnull &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如用来修饰一个变量，前面还要加双下划线，放到 block 里面就更加诡异，比如一个 Request 的 start 方法可以写成：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)startWithCompletionBlock:(nullable &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * __nullable error))block;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了这俩外，还有个 &lt;strong&gt;null_resettable&lt;/strong&gt; 来表示 setter nullable，但是 getter nonnull，绕死了，最直观例子就是 UIViewController 中的 view 属性：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (null_resettable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *view;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它可以被设成 nil，但是调用 getter 时会触发 &lt;code&gt;-loadView&lt;/code&gt; 从而创建并返回一个非 nil 的 view。&lt;br&gt;从 iOS9 SDK 中可以发现，头文件中所有 API 都已经增加了 Nullability 相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NS_ASSUME_NONNULL_BEGIN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;, nullable) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *workingCompany;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *friends;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)gayFriend;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NS_ASSUME_NONNULL_END&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable instancetype)URLWithString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)URLString;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;NSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。&lt;br&gt;不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。&lt;br&gt;所以 Nullability 总的来说就是，写着丑B，用着舒服 - -&lt;/p&gt;
&lt;h1 id=&quot;Lightweight-Generics&quot;&gt;&lt;a href=&quot;#Lightweight-Generics&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics&quot;&gt;&lt;/a&gt;Lightweight Generics&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Lightweight Generics&lt;/strong&gt; 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）  &lt;/p&gt;
&lt;h2 id=&quot;带泛型的容器&quot;&gt;&lt;a href=&quot;#带泛型的容器&quot; class=&quot;headerlink&quot; title=&quot;带泛型的容器&quot;&gt;&lt;/a&gt;带泛型的容器&lt;/h2&gt;&lt;p&gt;这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *strings = @[&lt;span class=&quot;string&quot;&gt;@&quot;sun&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;yuan&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; *mapping = @&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;a&quot;&lt;/span&gt;: @&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;b&quot;&lt;/span&gt;: @&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值的 &lt;strong&gt;id&lt;/strong&gt; 被替换成具体的类型后，令人感动的代码提示也出来了：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/51530583jw1et1s9igr0wj20jc03i74z.jpg&quot; width=&quot;480&quot;&gt;&lt;/p&gt;
&lt;p&gt;假如向泛型容器中加入错误的对象，编译器会不开心的：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1et1sf4799fj20oo02ywfh.jpg&quot; width=&quot;480&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *&amp;gt; *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。&lt;/p&gt;
&lt;h2 id=&quot;自定义泛型类&quot;&gt;&lt;a href=&quot;#自定义泛型类&quot; class=&quot;headerlink&quot; title=&quot;自定义泛型类&quot;&gt;&lt;/a&gt;自定义泛型类&lt;/h2&gt;&lt;p&gt;比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ObjectType&lt;/span&gt;&amp;gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)pushObject:(ObjectType)object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ObjectType)popObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;ObjectType&amp;gt; *allObjects;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 &lt;code&gt;ObjectType&lt;/code&gt; 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 &lt;strong&gt;T&lt;/strong&gt; 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 只接受 NSNumber * 的泛型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ObjectType&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 只接受满足 NSCopying 协议的泛型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ObjectType&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;NSCopying&lt;/span&gt;&amp;gt;&amp;gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。&lt;br&gt;实例化一个 Stack，一切工作正常：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1et2eqtxt07j20n6040wft.jpg&quot; width=&quot;480&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。&lt;/p&gt;
&lt;h2 id=&quot;协变性和逆变性&quot;&gt;&lt;a href=&quot;#协变性和逆变性&quot; class=&quot;headerlink&quot; title=&quot;协变性和逆变性&quot;&gt;&lt;/a&gt;协变性和逆变性&lt;/h2&gt;&lt;p&gt;当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack; &lt;span class=&quot;comment&quot;&gt;// Stack *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *stringStack; &lt;span class=&quot;comment&quot;&gt;// Stack&amp;lt;NSString *&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSMutableString&lt;/span&gt; *&amp;gt; *mutableStringStack; &lt;span class=&quot;comment&quot;&gt;// Stack&amp;lt;NSMutableString *&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/51530583jw1et2fajoo7bj210o09y78w.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的&lt;strong&gt;协变性&lt;/strong&gt;和&lt;strong&gt;逆变性&lt;/strong&gt;修饰符了：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;__covariant&lt;/code&gt; - 协变性，子类型可以强转到父类型（里氏替换原则）&lt;br&gt;&lt;code&gt;__contravariant&lt;/code&gt; - 逆变性，父类型可以强转到子类型（WTF?）  &lt;/p&gt;
&lt;p&gt;协变：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;__covariant&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ObjectType&lt;/span&gt;&amp;gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1et2frpvgzpj212q060q5f.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;逆变：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;__contravariant&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ObjectType&lt;/span&gt;&amp;gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1et2fsyrpfej212m05emzl.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。&lt;/p&gt;
&lt;h1 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot;__kindof&quot;&gt;&lt;/a&gt;__kindof&lt;/h1&gt;&lt;p&gt;__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)dequeueReusableCellWithIdentifier:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (__kindof &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)dequeueReusableCellWithIdentifier:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;__kindof &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *&amp;gt; *subviews;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，写下面的代码时就没有任何警告了：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *button = view.subviews.lastObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Where-to-go&quot;&gt;&lt;a href=&quot;#Where-to-go&quot; class=&quot;headerlink&quot; title=&quot;Where to go&quot;&gt;&lt;/a&gt;Where to go&lt;/h1&gt;&lt;p&gt;有了上面介绍的这些新特性以及如 &lt;strong&gt;instancetype&lt;/strong&gt; 这样的历史更新，Objective-C 这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的 &lt;strong&gt;id&lt;/strong&gt; 类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。&lt;br&gt;同时，个人感觉新版的 Xcode 对继承链构造器的检测也加强了，&lt;strong&gt;NS_DESIGNATED_INITIALIZER&lt;/strong&gt; 这个宏并不是新面孔，可以使用它标志出像 Swift 一样的指定构造器和便捷构造器。  &lt;/p&gt;
&lt;p&gt;最后，附上一段用上了所有新特性的代码，Swift 是发展趋势，如果你暂时依然要写 Objective-C 代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1et2iirmu7bj20ze0bojvm.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dd799517.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dd799517.aspx&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://gist.github.com/jtbandes/881f07a955ff2eadd1a0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gist.github.com/jtbandes/881f07a955ff2eadd1a0&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;请我喝瓶可乐？&quot;&gt;&lt;a href=&quot;#请我喝瓶可乐？&quot; class=&quot;headerlink&quot; title=&quot;请我喝瓶可乐？&quot;&gt;&lt;/a&gt;请我喝瓶可乐？&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1et2mwz8hqzj20af0camy7.jpg&quot; width=&quot;240&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;自 WWDC 2015 推出和开源 Swift 2.0 后，大家对 Swift 的热情又一次
    
    </summary>
    
    
      <category term="iOS9" scheme="http://blog.sunnyxx.com/tags/iOS9/"/>
    
  </entry>
  
  <entry>
    <title>一个丝滑的全屏滑动返回手势</title>
    <link href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/"/>
    <id>http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/</id>
    <published>2015-06-07T02:15:04.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;全屏返回手势&quot;&gt;&lt;a href=&quot;#全屏返回手势&quot; class=&quot;headerlink&quot; title=&quot;全屏返回手势&quot;&gt;&lt;/a&gt;全屏返回手势&lt;/h1&gt;&lt;p&gt;自 iOS7 之后，Apple 增加了&lt;strong&gt;屏幕边缘右划返回&lt;/strong&gt;交互的支持，再配合上 UINavigationController 的交互式动画，pop 到上一级页面的操作变的非常顺畅和丝滑，从此，我很少再使用点击左上角导航栏上的返回按钮的方式返回了，因为这对单手操作十分不友好；如果一个 App 居然胆敢不支持滑动返回，那离被卸载就不远了。  &lt;/p&gt;
&lt;p&gt;说到&lt;strong&gt;全屏返回手势&lt;/strong&gt;，首先我感觉这件事本身可能就有问题，毕竟有点反苹果官方的交互，让用户从任意的地方都能够滑动返回这个交互在国内的 App 中非常普遍，比如我手机中的手Q、微博、网易新闻、大众点评等，当然还有百度知道- -。这里得对微信的产品经理们得点个赞，从整个 App 来看，不论是交互还是 UI 结构和样式都非常的 iOS，没有什么特别奇葩的页面和交互，以至于使用 UIKit 原生的框架可以非常简单的搭建起来，这也符合我个人对 App 的一个愿景：&lt;strong&gt;一个优秀的 App 不论从用户角度看还是从代码角度看都应该是简单且优雅的&lt;/strong&gt;，呼吁各家产品经理可以多借鉴下像微信这样很本色的 App 设计。（以后可以分享下如何使用 Storyboard 在一小时内快速搭建起微信 UI）  &lt;/p&gt;
&lt;h1 id=&quot;FDFullscreenPopGesture&quot;&gt;&lt;a href=&quot;#FDFullscreenPopGesture&quot; class=&quot;headerlink&quot; title=&quot;FDFullscreenPopGesture&quot;&gt;&lt;/a&gt;FDFullscreenPopGesture&lt;/h1&gt;&lt;p&gt;工作毕竟是工作，于是乎所以就被迫实现了套 pan 手势处理加截图和视差，虽然在运动曲线上、bar 截图处理上下了不少功夫，但距离系统的丝滑效果还是差距挺远。随时间推移，终于能够最低支持 iOS7 后，我们把这个问题再次拿出来讨论和研究，直到在微博上看到了 &lt;strong&gt;J_雨&lt;/strong&gt;同学的&lt;a href=&quot;http://www.jianshu.com/p/d39f7d22db6c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt; 后才找到了这个迄今为止最简单的解决方案。于是乎在他的授权下，我们在 forkingdog 上把这个返回手势开源，&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;，并果断应用到了百度知道 App 内，这是 Demo 效果：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot0.gif&quot; alt=&quot;&quot;&gt;   &lt;/p&gt;
&lt;p&gt;利用了系统自己的边缘返回手势处理函数后，一切动画和曲线都和原生效果一毛一样了。&lt;br&gt;于是乎发布了 &lt;code&gt;FDFullscreenPopGesture&lt;/code&gt; 1.0 版本，而且提供了一个 AOP 形式的 API，把它添加到工程里面，什么代码都不用写，所有 UINavigationController 就自带这个全屏返回效果了。  &lt;/p&gt;
&lt;h1 id=&quot;丝滑的处理导航栏的显示和隐藏&quot;&gt;&lt;a href=&quot;#丝滑的处理导航栏的显示和隐藏&quot; class=&quot;headerlink&quot; title=&quot;丝滑的处理导航栏的显示和隐藏&quot;&gt;&lt;/a&gt;丝滑的处理导航栏的显示和隐藏&lt;/h1&gt;&lt;p&gt;接下来我们发现利用系统的 UINavigationBar 时，返回手势中若碰到前一个页面有 bar，后一个页面没 bar，或者反过来时，动画就非常难看，举两个反例：  &lt;/p&gt;
&lt;p&gt;手Q iOS：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1esvbwqgawtg208w0fvu0x.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它的个人中心页面上面的 bar 是隐藏状态，然后做了个和其他页面很像的假 bar，但返回手势一开始就露馅了，为了弥补，还做了下后面真 bar 的 alpha 值动画，两个返回按钮还是重叠在了一起。  &lt;/p&gt;
&lt;p&gt;新浪微博 iOS：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1esvbwfphj8g208w0fv4qp.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;和手Q一样的实现方式，只不过没做 alpha 动画，所以就非常明显了。  &lt;/p&gt;
&lt;p&gt;为啥会这样呢？这可能就是 UINavigationController 在导航栏控制 API 上设计的缺陷了。 一个 UINavigationController 管理了串行的 N 个 UIViewController 栈式的 push 和 pop，而 UINavigationBar 由 UINavigationController 管理，这就导致了 UIViewController 无法控制自己上面的 bar 单独的隐藏或显示。 这非常像 UIApplication 全局的 status bar，牵一发还得动全身，不过 Apple 在 iOS7 之后为 vc 控制自己的 status bar 提供了下面几个方法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIStatusBarStyle&lt;/span&gt;)preferredStatusBarStyle &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)prefersStatusBarHidden &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIStatusBarAnimation&lt;/span&gt;)preferredStatusBarUpdateAnimation &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;终于让这个&lt;strong&gt;全局变量&lt;/strong&gt;变成了&lt;strong&gt;局部变量&lt;/strong&gt;，虽然写起来费劲了些。&lt;br&gt;但是对 UINavigationBar 的控制，依然是全局的，可能 Apple 觉得 App 不应该有这种奇怪的页面结构？  &lt;/p&gt;
&lt;p&gt;解决这个问题的方法也不难，在滑动返回的后要出现的那个 view controller 中写下面的代码：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewWillAppear:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController setNavigationBarHidden:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; animated:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;系统就会把有 bar 和 无 bar 的 transition 动画衔接起来。但是如上面所说，这是个全局变量，还得在所有由这个没有 bar 的特殊页面能 push 和 pop 的页面都进行反向的处理，代码非常的乱乎。于是乎，我们试着解决了这个问题，先看效果：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1esvbwmjck8g208w0ft7wj.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我特意挑了个从真 bar 到假 bar，再从假 bar 到 真 bar 的页面，还算蛮丝滑的，transition 动画全是系统自己搞定的。&lt;br&gt;就事把 &lt;code&gt;FDFullscreenPopGesture&lt;/code&gt; 更新到了 1.1 版本，贯彻我们一向的精简 API，你只需要在 bar 要隐藏的 view controller 中写一句话：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController.fd_prefersNavigationBarHidden = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者喜欢重载的写法也行：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)fd_prefersNavigationBarHidden &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;刻意的模仿了下系统的命名风格，就这一句话，剩下的就都不用操心了。  &lt;/p&gt;
&lt;h1 id=&quot;关于私有API&quot;&gt;&lt;a href=&quot;#关于私有API&quot; class=&quot;headerlink&quot; title=&quot;关于私有API&quot;&gt;&lt;/a&gt;关于私有API&lt;/h1&gt;&lt;p&gt;大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？&lt;br&gt;首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。&lt;br&gt;另一个就是审核问题，FDFullscreenPopGesture 的实现中有主要有两处触碰到了私有 API：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1. 私有变量标志transition动画是否正在进行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController valueForKey:&lt;span class=&quot;string&quot;&gt;@&quot;_isTransitioning&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2. 一个内部的selector&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;handleNavigationTransition:&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？  &lt;/p&gt;
&lt;p&gt;首先，这个检查一定是个静态检查吧，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。&lt;br&gt;对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。  &lt;/li&gt;
&lt;li&gt;同上，使用&lt;code&gt;@selector(_private_sel)&lt;/code&gt;加上&lt;code&gt;-performSelector:&lt;/code&gt;的方式直接调用私有 API。&lt;/li&gt;
&lt;li&gt;扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。&lt;/li&gt;
&lt;li&gt;扫描所有&lt;strong&gt;string&lt;/strong&gt;，看字符串常量段是否出现和私有 API 对应的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 &lt;code&gt;handleNavigationTransition:&lt;/code&gt; 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。&lt;br&gt;综上，我觉得使用字符串的方式使用私有 API 是相对安全的，我们的 App 马上要提交审核，如果过了几天你还能读到这段文字，说明我的猜想是木有错的，大家可以放心使用。&lt;/p&gt;
&lt;h1 id=&quot;0-代码的-Demo&quot;&gt;&lt;a href=&quot;#0-代码的-Demo&quot; class=&quot;headerlink&quot; title=&quot;0 代码的 Demo&quot;&gt;&lt;/a&gt;0 代码的 Demo&lt;/h1&gt;&lt;p&gt;还有一个有意思的事，我们在 github 上的 &lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo工程&lt;/a&gt; 木有写一行代码，就实现了下面的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/forkingdog/FDFullscreenPopGesture/master/Snapshots/snapshot1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;工程长这个样子，view controller 类也没写，为了体现 &lt;code&gt;FDFullscreenPopGesture&lt;/code&gt; 的 AOP 性质：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/51530583jw1esveprvnvfj20ju0d2tbm.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;页面由 Storyboard 构建：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/51530583jw1esvepscqomj212m10eq5a.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;而控制页面隐藏 bar 的属性也能用 Runtime Attributes 模拟调用：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1esvetev633j20ig05ydgl.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了一个非常干净的 Demo&lt;/p&gt;
&lt;h1 id=&quot;加入到你的工程中&quot;&gt;&lt;a href=&quot;#加入到你的工程中&quot; class=&quot;headerlink&quot; title=&quot;加入到你的工程中&quot;&gt;&lt;/a&gt;加入到你的工程中&lt;/h1&gt;&lt;p&gt;首先要求最低支持 iOS7，我想在 WWDC 2015 结束，iOS9 发布后，主流的 App 就都会 iOS7 起跳了。&lt;br&gt;依然是熟悉的 cocoapods 安装：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &#39;FDFullscreenPopGesture&#39;, &#39;~&amp;gt; 1.1&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要是没有搜到就 &lt;code&gt;pod setup&lt;/code&gt; 下。&lt;/p&gt;
&lt;h1 id=&quot;广告时间&quot;&gt;&lt;a href=&quot;#广告时间&quot; class=&quot;headerlink&quot; title=&quot;广告时间&quot;&gt;&lt;/a&gt;广告时间&lt;/h1&gt;&lt;p&gt;我这边正在招聘 iOS，坐标北京，希望找到一个代码规范的、爱用 IB 的、懒得写重复代码、不爱加班的同学，相信这里有很大空间供你学习和提升，还可以参与到 forkingdog 开源小组中做点屌屌的东西，欢迎私聊或把简历丢到 sunyuan01@baidu.com   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全屏返回手势&quot;&gt;&lt;a href=&quot;#全屏返回手势&quot; class=&quot;headerlink&quot; title=&quot;全屏返回手势&quot;&gt;&lt;/a&gt;全屏返回手势&lt;/h1&gt;&lt;p&gt;自 iOS7 之后，Apple 增加了&lt;strong&gt;屏幕边缘右划返回&lt;/strong&gt;交互的支持，再配合上
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>优化UITableViewCell高度计算的那些事</title>
    <link href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/"/>
    <id>http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</id>
    <published>2015-05-17T10:50:08.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;这篇文章是我和我们团队最近对 &lt;strong&gt;UITableViewCell&lt;/strong&gt; 利用 &lt;strong&gt;AutoLayout&lt;/strong&gt; 自动高度计算和 &lt;strong&gt;UITableView&lt;/strong&gt; 滑动优化的一个总结。&lt;br&gt;我们也在维护一个开源的扩展，&lt;code&gt;UITableView+FDTemplateLayoutCell&lt;/code&gt;，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，&lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github链接请戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇总结你可以读到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UITableView高度计算和估算的机制&lt;/li&gt;
&lt;li&gt;不同iOS系统在高度计算上的差异&lt;/li&gt;
&lt;li&gt;iOS8 self-sizing cell&lt;/li&gt;
&lt;li&gt;UITableView+FDTemplateLayoutCell如何用一句话解决高度问题&lt;/li&gt;
&lt;li&gt;UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;UITableViewCell高度计算&quot;&gt;&lt;a href=&quot;#UITableViewCell高度计算&quot; class=&quot;headerlink&quot; title=&quot;UITableViewCell高度计算&quot;&gt;&lt;/a&gt;UITableViewCell高度计算&lt;/h1&gt;&lt;h2 id=&quot;rowHeight&quot;&gt;&lt;a href=&quot;#rowHeight&quot; class=&quot;headerlink&quot; title=&quot;rowHeight&quot;&gt;&lt;/a&gt;rowHeight&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt;是我们再熟悉不过的视图了，它的 &lt;strong&gt;delegate&lt;/strong&gt; 和 &lt;strong&gt;data source&lt;/strong&gt; 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。&lt;br&gt;一种是针对所有 Cell 具有固定高度的情况，通过：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tableView.rowHeight = &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，&lt;strong&gt;强烈建议&lt;/strong&gt;使用这种（而非下面的）方式保证不必要的高度计算和调用。&lt;code&gt;rowHeight&lt;/code&gt;属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。&lt;/p&gt;
&lt;p&gt;另一种方式就是实现 UITableViewDelegate 中的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView heightForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// return xxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，实现了这个方法后，&lt;code&gt;rowHeight&lt;/code&gt; 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。&lt;/p&gt;
&lt;h2 id=&quot;estimatedRowHeight&quot;&gt;&lt;a href=&quot;#estimatedRowHeight&quot; class=&quot;headerlink&quot; title=&quot;estimatedRowHeight&quot;&gt;&lt;/a&gt;estimatedRowHeight&lt;/h2&gt;&lt;p&gt;这个属性 iOS7 就出现了， 文档是这么描述它的作用的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 &lt;code&gt;contentSize&lt;/code&gt; 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在&lt;strong&gt;屏幕外边&lt;/strong&gt;的 cell 上。和上面的 &lt;code&gt;rowHeight&lt;/code&gt; 很类似，设置这个估算高度有两种方法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tableView.estimatedRowHeight = &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView estimatedHeightForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// return xxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 &lt;code&gt;estimatedRowHeight&lt;/code&gt; 属性赋值，只要&lt;strong&gt;整体估算值接近&lt;/strong&gt;就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。  &lt;/p&gt;
&lt;p&gt;说完了估算高度的基本使用，可以开始吐槽了：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。&lt;/li&gt;
&lt;li&gt;若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。&lt;/li&gt;
&lt;li&gt;估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&quot;iOS8-self-sizing-cell&quot;&gt;&lt;a href=&quot;#iOS8-self-sizing-cell&quot; class=&quot;headerlink&quot; title=&quot;iOS8 self-sizing cell&quot;&gt;&lt;/a&gt;iOS8 self-sizing cell&lt;/h1&gt;&lt;p&gt;具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + ...;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;供 UITableViewDelegate 调用时很可能是个 cell 的类方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BubbleCell&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UITableViewCell&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)heightWithEntity:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)entity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;各种魔法 margin 加上耦合了屏幕宽度。&lt;/p&gt;
&lt;p&gt;AutoLayout 时代好了不少，提供了&lt;code&gt;-systemLayoutSizeFittingSize:&lt;/code&gt;的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 &lt;code&gt;template layout cell&lt;/code&gt;，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。  &lt;/p&gt;
&lt;p&gt;这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 &lt;code&gt;preferredMaxLayoutWidth&lt;/code&gt; 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）&lt;/p&gt;
&lt;p&gt;回到正题，iOS8 WWDC 中推出了 &lt;code&gt;self-sizing cell&lt;/code&gt; 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1es3hwpsb71j20pe0f2ab4.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tableView.estimatedRowHeight = &lt;span class=&quot;number&quot;&gt;213&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tableView.rowHeight = &lt;span class=&quot;built_in&quot;&gt;UITableViewAutomaticDimension&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -&lt;br&gt;PS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。  &lt;/p&gt;
&lt;p&gt;问题：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。  &lt;/li&gt;
&lt;li&gt;求一个能让最低支持 iOS8 的公司- -&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&quot;iOS8抽风的算高机制&quot;&gt;&lt;a href=&quot;#iOS8抽风的算高机制&quot; class=&quot;headerlink&quot; title=&quot;iOS8抽风的算高机制&quot;&gt;&lt;/a&gt;iOS8抽风的算高机制&lt;/h1&gt;&lt;p&gt;相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/51530583jw1es3j7avlelj20w4084jsv.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;研究后发现这么多次额外计算有下面的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dequeueReusableCellWithIdentifier:forIndexPath:&lt;/code&gt; 相比不带 “forIndexPath” 的版本会多调用一次高度计算&lt;/li&gt;
&lt;li&gt;iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;iOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。  &lt;/p&gt;
&lt;p&gt;说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;UITableView-FDTemplateLayoutCell&quot;&gt;&lt;a href=&quot;#UITableView-FDTemplateLayoutCell&quot; class=&quot;headerlink&quot; title=&quot;UITableView+FDTemplateLayoutCell&quot;&gt;&lt;/a&gt;UITableView+FDTemplateLayoutCell&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;UITableView+FDTemplateLayoutCell&lt;/code&gt; 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。&lt;br&gt;使用起来大概是这样：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;UITableView+FDTemplateLayoutCell.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView heightForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [tableView fd_heightForCellWithIdentifier:&lt;span class=&quot;string&quot;&gt;@&quot;identifer&quot;&lt;/span&gt; cacheByIndexPath:indexPath configuration:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; cell) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell.entity = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.feedEntities[indexPath.row];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;写完上面的代码后，你就已经使用到了：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;和每个 UITableViewCell ReuseID 一一对应的 template layout cell&lt;/strong&gt;&lt;br&gt;这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 &lt;code&gt;-dequeueCellForReuseIdentifier:&lt;/code&gt; 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 &lt;code&gt;-registerClass:forCellReuseIdentifier:&lt;/code&gt; 或 &lt;code&gt;-registerNib:forCellReuseIdentifier:&lt;/code&gt;其中之一的注册方法。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据 autolayout 约束自动计算高度&lt;/strong&gt;&lt;br&gt;使用了系统在 iOS6 就提供的 API：&lt;code&gt;-systemLayoutSizeFittingSize:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据 index path 的一套高度缓存机制&lt;/strong&gt;&lt;br&gt;计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动的缓存失效机制&lt;/strong&gt;&lt;br&gt;无须担心你数据源的变化引起的缓存失效，当调用如&lt;code&gt;-reloadData&lt;/code&gt;，&lt;code&gt;-deleteRowsAtIndexPaths:withRowAnimation:&lt;/code&gt;等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以&lt;strong&gt;最小的代价&lt;/strong&gt;执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预缓存机制&lt;/strong&gt;&lt;br&gt;预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在设计这个工具的 API 时斟酌了非常长的时间，既要保证功能的强大，也要保证接口的精简，一行调用背后隐藏着很多功能。&lt;/p&gt;
&lt;p&gt;这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，我还做了个小测试：&lt;br&gt;一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 &lt;code&gt;Time Profiler&lt;/code&gt; 监测算高函数所花费的时间：  &lt;/p&gt;
&lt;p&gt;未使用缓存API、未使用估算，共花费 877 ms：&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1es7f5l357cj213k0g07eh.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用缓存API、开启估算，共花费 77 ms：&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/51530583jw1es7f5lefy3j21440hsgw8.jpg&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -  &lt;/p&gt;
&lt;p&gt;同时，工具也顺手解决了&lt;code&gt;-preferredMaxLayoutWidth&lt;/code&gt;的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;利用RunLoop空闲时间执行预缓存任务&quot;&gt;&lt;a href=&quot;#利用RunLoop空闲时间执行预缓存任务&quot; class=&quot;headerlink&quot; title=&quot;利用RunLoop空闲时间执行预缓存任务&quot;&gt;&lt;/a&gt;利用RunLoop空闲时间执行预缓存任务&lt;/h1&gt;&lt;p&gt;FDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于&lt;strong&gt;空闲&lt;/strong&gt;状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。&lt;br&gt;一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有&lt;code&gt;RunLoop&lt;/code&gt;这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。  &lt;/p&gt;
&lt;h2 id=&quot;空闲RunLoopMode&quot;&gt;&lt;a href=&quot;#空闲RunLoopMode&quot; class=&quot;headerlink&quot; title=&quot;空闲RunLoopMode&quot;&gt;&lt;/a&gt;空闲RunLoopMode&lt;/h2&gt;&lt;p&gt;在曾经的 RunLoop 线下分享会（&lt;a href=&quot;http://yun.baidu.com/share/link?shareid=2268593032&amp;amp;uk=2885973690&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频可戳&lt;/a&gt;）中介绍了 RunLoopMode 的概念。&lt;br&gt;当用户正在滑动 UIScrollView 时，RunLoop 将切换到 &lt;code&gt;UITrackingRunLoopMode&lt;/code&gt; 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。&lt;br&gt;当 UI 没在滑动时，默认的 Mode 是 &lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt;（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。&lt;/p&gt;
&lt;h2 id=&quot;用RunLoopObserver找准时机&quot;&gt;&lt;a href=&quot;#用RunLoopObserver找准时机&quot; class=&quot;headerlink&quot; title=&quot;用RunLoopObserver找准时机&quot;&gt;&lt;/a&gt;用RunLoopObserver找准时机&lt;/h2&gt;&lt;p&gt;注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RunLoop开始&lt;/li&gt;
&lt;li&gt;RunLoop即将处理Timer&lt;/li&gt;
&lt;li&gt;RunLoop即将处理Source&lt;/li&gt;
&lt;li&gt;RunLoop即将进入休眠状态&lt;/li&gt;
&lt;li&gt;RunLoop即将从休眠状态被事件唤醒&lt;/li&gt;
&lt;li&gt;RunLoop退出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RunLoop 处于“空闲”状态 Mode&lt;/li&gt;
&lt;li&gt;当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 CF 的带 block 版本的注册函数可以让代码更简洁：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; runLoopMode = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt; observer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverCreateWithHandler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeWaiting&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ^(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt; observer, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopActivity&lt;/span&gt; _) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TODO here&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddObserver&lt;/span&gt;(runLoop, observer, runLoopMode);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer  &lt;/p&gt;
&lt;h2 id=&quot;分解成多个RunLoop-Source任务&quot;&gt;&lt;a href=&quot;#分解成多个RunLoop-Source任务&quot; class=&quot;headerlink&quot; title=&quot;分解成多个RunLoop Source任务&quot;&gt;&lt;/a&gt;分解成多个RunLoop Source任务&lt;/h2&gt;&lt;p&gt;假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们&lt;strong&gt;分别分解&lt;/strong&gt;到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）&lt;br&gt;Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)performSelector:(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               onThread:(&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *)thr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)arg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          waitUntilDone:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)wait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  modes:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)array;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”&lt;br&gt;于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *mutableIndexPathsToBePrecached = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.fd_allIndexPathsToBePrecached.mutableCopy;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt; observer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverCreateWithHandler&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeWaiting&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ^(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt; observer, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopActivity&lt;/span&gt; _) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mutableIndexPathsToBePrecached.count == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRemoveObserver&lt;/span&gt;(runLoop, observer, runLoopMode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRelease&lt;/span&gt;(observer); &lt;span class=&quot;comment&quot;&gt;// 注意释放，否则会造成内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *indexPath = mutableIndexPathsToBePrecached.firstObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [mutableIndexPathsToBePrecached removeObject:indexPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; performSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(fd_precacheIndexPathIfNeeded:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 onThread:[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; mainThread]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               withObject:indexPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            waitUntilDone:&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    modes:@[&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。  &lt;/p&gt;
&lt;p&gt;PS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;开始使用UITableView-FDTemplateLayoutCell&quot;&gt;&lt;a href=&quot;#开始使用UITableView-FDTemplateLayoutCell&quot; class=&quot;headerlink&quot; title=&quot;开始使用UITableView+FDTemplateLayoutCell&quot;&gt;&lt;/a&gt;开始使用UITableView+FDTemplateLayoutCell&lt;/h1&gt;&lt;p&gt;如果你觉得这个工具能帮得到你，整合到工程也十分简单。&lt;br&gt;使用 cocoapods：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod search UITableView+FDTemplateLayoutCell&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;写这篇文章时的最新版本为 1.2，去除了前一个版本的黑魔法，增加了预缓存功能。&lt;br&gt;欢迎使用和支持这个工具，有 bug 请随时反馈哦~&lt;br&gt;再复习下 github 地址： &lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/7244961/4209de32-e816-11e4-87bc-b161c442d348.png&quot; width=&quot;640&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;这篇文章是我和我们团队最近对 &lt;strong&gt;UITableViewCell&lt;/strong&gt; 利用 &lt;strong&gt;Aut
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>巧用多字符Char常量</title>
    <link href="http://blog.sunnyxx.com/2015/05/07/multiple-char/"/>
    <id>http://blog.sunnyxx.com/2015/05/07/multiple-char/</id>
    <published>2015-05-07T00:03:20.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;###巧用多字符Char&lt;/p&gt;
&lt;p&gt;我们很熟悉&lt;code&gt;char&lt;/code&gt;这个数据类型和它的使用方式：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 c 变量在 &lt;strong&gt;ASCII&lt;/strong&gt; 编码下是 &lt;strong&gt;97&lt;/strong&gt;&lt;br&gt;还有一种不常见的多字符 char 的写法：  &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int i = &#39;AaBb&#39;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 i 变量的值按每个 char 的 ASCII 值转 16 进制拼在一起，也就是说：  &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&#39;AaBb&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; &#39;0x41&#39;+&#39;0x61&#39;+&#39;0x42&#39;+&#39;0x62&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; &#39;0x41614262&#39; // 十进制1096893026&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PS：这个组合方式和“大小端”有关系，上面是 i386 下的结果&lt;br&gt;多字符的长度限度为最多 &lt;strong&gt;4&lt;/strong&gt; 个 char&lt;/p&gt;
&lt;p&gt;知道了这个特性，我们就可以做些坏事，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.someButton.tag = &#39;SHIT&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (button.tag == &#39;SHIT&#39;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;I&#39;ve got this shit button&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然使用tag是很不推荐的写法，尽量不用。使用这个特性来避免些魔法数字或标记些整型数字还是极好的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###巧用多字符Char&lt;/p&gt;
&lt;p&gt;我们很熟悉&lt;code&gt;char&lt;/code&gt;这个数据类型和它的使用方式：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
    
    </summary>
    
    
      <category term="wtf" scheme="http://blog.sunnyxx.com/tags/wtf/"/>
    
  </entry>
  
  <entry>
    <title>0代码隐藏GroupedTableView上边多余的间隔</title>
    <link href="http://blog.sunnyxx.com/2015/04/15/ios-hide-grouped-tableview-header/"/>
    <id>http://blog.sunnyxx.com/2015/04/15/ios-hide-grouped-tableview-header/</id>
    <published>2015-04-15T10:50:10.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/51530583jw1er6hby1sp0j20nq0tk768.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过会有下面的问题，第一个 Section 距离屏幕顶端有间隔&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/51530583jw1er6hbxkv2xj20k80oota0.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一行代码搞定&quot;&gt;&lt;a href=&quot;#一行代码搞定&quot; class=&quot;headerlink&quot; title=&quot;一行代码搞定&quot;&gt;&lt;/a&gt;一行代码搞定&lt;/h3&gt;&lt;p&gt;研究发现，这里其实是一个被 UITableView 默认填充的 HeaderView。而且，当试图将它的高度设置为 0 时，完全不起效果。但我们用下面的代码创建一个高度特别小的 HeaderView 时，上面的边距就不见了：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583jw1er6jpgw0ndj20u40600ud.jpg&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CGFLOAT_MIN&lt;/code&gt; 这个宏表示 CGFloat 能代表的最接近 0 的浮点数，64 位下大概是 0.00(300左右个)0225 这个样子&lt;br&gt;这样写单纯的为了避免一个魔法数字，这里用 &lt;code&gt;0.1&lt;/code&gt; 效果是一样的，后面再讲。 &lt;/p&gt;
&lt;h3 id=&quot;在-Storyboard-中-0-代码搞定&quot;&gt;&lt;a href=&quot;#在-Storyboard-中-0-代码搞定&quot; class=&quot;headerlink&quot; title=&quot;在 Storyboard 中 0 代码搞定&quot;&gt;&lt;/a&gt;在 Storyboard 中 0 代码搞定&lt;/h3&gt;&lt;p&gt;没用 Storyboard 的同学使用上面的代码就 OK 了； 而在 Storyboard 中可以 0 代码搞定这个事：  &lt;/p&gt;
&lt;p&gt;首先，在第一个 Section 的上面拖进来一个空 UIView &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7na5uj20aw07cwfi.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 &lt;code&gt;frame&lt;/code&gt; 的 KeyPath &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1er6jd7wt02j20f6064wf8.jpg&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样头部的间隔就乖乖的不见了：   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/51530583jw1er6jj5n61fj20ju0lidgi.jpg
&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;刨根问底-UITableViewHeader-的猫腻&quot;&gt;&lt;a href=&quot;#刨根问底-UITableViewHeader-的猫腻&quot; class=&quot;headerlink&quot; title=&quot;刨根问底 UITableViewHeader 的猫腻&quot;&gt;&lt;/a&gt;刨根问底 UITableViewHeader 的猫腻&lt;/h3&gt;&lt;p&gt;为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若传入的 height == 0，则 height 被设置成默认值&lt;/li&gt;
&lt;li&gt;若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;半像素也就是 &lt;code&gt;1.0 / scale / 2.0&lt;/code&gt;，如在 @2x 屏上是 0.25&lt;br&gt;直观的感受下，假如这个 height 被设置成 0.5 的样子：&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1er6kdmuz21j20ju0de0u4.jpg
&quot; width=&quot;320&quot;&gt;&lt;/p&gt;
&lt;p&gt;身患强迫症的我是绝对不能容忍导航栏下面的阴影线看上去宽了 0.5 像素的，Done。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;实现诸如支付宝的 “探索” 页面时，最简单的方案是在 Storyboard 中来一个静态 Grouped UITableViewController，把各个 Cell 中的元素摆好就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw69
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Xcode Tip合集</title>
    <link href="http://blog.sunnyxx.com/2015/03/29/xcode-tips/"/>
    <id>http://blog.sunnyxx.com/2015/03/29/xcode-tips/</id>
    <published>2015-03-29T11:48:42.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xm000o1j20oq0i4786.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/51530583jw1eq8xlzf1kqj20mw0lcaeg.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/51530583gw1eqccw0644jj20ka0lq43i.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/51530583gw1eqccvzvkexj20mu0lajv2.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/51530583gw1eqccvyqgd1j20ow0sednl.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/51530583jw1eqkfye958bj20j60zi7d7.jpg&quot; width=&quot;500&quot;&gt;  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近总结了几个 Xcode 小技巧，在微博上（@我就叫Sunny怎么了）都发过，来个合集：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/51530583jw1eq8xm0otg5j20qk0wk45d.jpg&quot; width=&quot;
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Notification Once</title>
    <link href="http://blog.sunnyxx.com/2015/03/09/notification-once/"/>
    <id>http://blog.sunnyxx.com/2015/03/09/notification-once/</id>
    <published>2015-03-09T11:31:55.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间整理项目中的&lt;code&gt;AppDelegate&lt;/code&gt;，发现很多写在&lt;code&gt;- application:didFinishLaunchingWithOptions:&lt;/code&gt;中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;didFinishLaunchingWithOptions:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)launchOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [FooModule setup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[BarModule sharedInstance] setup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实这些代码完全可以利用&lt;code&gt;Notification&lt;/code&gt;的方式在自己的模块内部搞定，分享一个巧妙的方法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// FooModule.m&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)load&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; observer =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     addObserverForName:&lt;span class=&quot;built_in&quot;&gt;UIApplicationDidFinishLaunchingNotification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     queue:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     usingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt; *note) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; setup]; &lt;span class=&quot;comment&quot;&gt;// Do whatever you want&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter] removeObserver:observer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ load&lt;/code&gt;方法在足够早的时间点被调用&lt;/li&gt;
&lt;li&gt;block 版本的通知注册会产生一个&lt;code&gt;__NSObserver *&lt;/code&gt;对象用来给外部 remove 观察者&lt;/li&gt;
&lt;li&gt;block 对 observer 对象的捕获早于函数的返回，所以若不加&lt;code&gt;__block&lt;/code&gt;，会捕获到 nil&lt;/li&gt;
&lt;li&gt;在 block 执行结束时移除 observer，无需其他清理工作&lt;/li&gt;
&lt;li&gt;这样，在模块内部就完成了在程序启动点代码的挂载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得注意的是，通知是在&lt;code&gt;- application:didFinishLaunchingWithOptions:&lt;/code&gt;调用完成后才发送的。&lt;br&gt;顺便提下给 AppDelegate 瘦身的建议：AppDelegate 作为程序级状态变化的 delegate，应该只做&lt;strong&gt;路由&lt;/strong&gt;和&lt;strong&gt;分发&lt;/strong&gt;的作用，具体逻辑实现代码还是应该在分别的模块中，这个文件应该保持整洁，除了&lt;code&gt;&amp;lt;UIApplicationDelegate&amp;gt;&lt;/code&gt;的方法外不应该出现其他方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间整理项目中的&lt;code&gt;AppDelegate&lt;/code&gt;，发现很多写在&lt;code&gt;- application:didFinishLaunchingWithOptions:&lt;/code&gt;中的代码都只是为了在程序启动时获得一次调用机会，多为某些模块的初始化工作，如：
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>实现一个TODO宏</title>
    <link href="http://blog.sunnyxx.com/2015/03/01/todo-macro/"/>
    <id>http://blog.sunnyxx.com/2015/03/01/todo-macro/</id>
    <published>2015-03-01T04:12:12.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/51530583jw1eprfhhspaqj20nu0bqae6.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面一步步来实现这个宏。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Let’s-do-it&quot;&gt;&lt;a href=&quot;#Let’s-do-it&quot; class=&quot;headerlink&quot; title=&quot;Let’s do it&quot;&gt;&lt;/a&gt;Let’s do it&lt;/h1&gt;&lt;p&gt;手动让编译器报警（报错）可以用以下几个方法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#warning sunnyxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#error sunnyxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#pragma message &lt;span class=&quot;meta-string&quot;&gt;&quot;sunnyxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#pragma GCC warning &lt;span class=&quot;meta-string&quot;&gt;&quot;sunnyxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#pragma GCC error &lt;span class=&quot;meta-string&quot;&gt;&quot;sunnyxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但我们知道，带&lt;code&gt;#&lt;/code&gt;的预处理指令是无法被&lt;code&gt;#define&lt;/code&gt;的。好在&lt;strong&gt;C99&lt;/strong&gt;提供了一个&lt;code&gt;_Pragma&lt;/code&gt;运算符可以把部分&lt;code&gt;#pragma&lt;/code&gt;指令字符串化：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#pragma message &lt;span class=&quot;meta-string&quot;&gt;&quot;sunnyxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_Pragma(&lt;span class=&quot;string&quot;&gt;&quot;message \&quot;sunnyxx\&quot;&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 需要注意双引号的转义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_Pragma(&lt;span class=&quot;string&quot;&gt;&quot;message(\&quot;sunnyxx\&quot;)&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 需要注意双引号的转义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;利用这个特性，我们就可以将warning定义成宏&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define SOME_WARNING _Pragma(&lt;span class=&quot;meta-string&quot;&gt;&quot;message(\&quot;&lt;/span&gt;报告大王！\&lt;span class=&quot;meta-string&quot;&gt;&quot;)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SOME_WARNING &lt;span class=&quot;comment&quot;&gt;// [!]报告大王！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，我们让这个宏能够接受入参，并显示到warning中去，这里会面临宏的基本用法的考验。   &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define STRINGIFY(S) #S&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;个人认为不太可能在一个宏定义中完成这件事，需要用到辅助宏：&lt;code&gt;STRINGIFY(S)&lt;/code&gt; 将入参转化成字符串，省去了&lt;code&gt;_Pragma&lt;/code&gt;中全串加转义字符的困扰。&lt;br&gt;这时，一个基本功能的TODO宏就完成了，下面向其中加入&lt;strong&gt;额外的信息&lt;/strong&gt;：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 两个已有的宏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define STRINGIFY(S) #S&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 延迟1次展开的宏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define DEFER_STRINGIFY(S) STRINGIFY(S)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 下面的宏在第一行用`\`折行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define FORMATTED_MESSAGE(MSG) &lt;span class=&quot;meta-string&quot;&gt;&quot;[TODO-&quot;&lt;/span&gt; DEFER_STRINGIFY(__COUNTER__) &lt;span class=&quot;meta-string&quot;&gt;&quot;] &quot;&lt;/span&gt; MSG &lt;span class=&quot;meta-string&quot;&gt;&quot; \n&quot;&lt;/span&gt;  \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DEFER_STRINGIFY(__FILE__) &lt;span class=&quot;string&quot;&gt;&quot; line &quot;&lt;/span&gt; DEFER_STRINGIFY(__LINE__)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中涉及到的知识：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个常量字符串可以拼接成一个整串 “123””456” =&amp;gt; “123456”&lt;/li&gt;
&lt;li&gt;使用到3个&lt;strong&gt;预定义宏&lt;/strong&gt;，&lt;code&gt;__COUNTER__&lt;/code&gt;宏展开次数的计数器，全局唯一；&lt;code&gt;__FILE__&lt;/code&gt;当前文件完整目录字符串；&lt;code&gt;__LINE__&lt;/code&gt;在当前文件第几行&lt;/li&gt;
&lt;li&gt;在字符串中&lt;strong&gt;预定义宏&lt;/strong&gt;应延时展开，如果将上面的&lt;code&gt;DEFER_STRINGIFY&lt;/code&gt;换成&lt;code&gt;STRINGIFY&lt;/code&gt;的话，如&lt;code&gt;__LINE__&lt;/code&gt;就不能被正确展开成行数，而是成了一个常量字符串&lt;code&gt;&amp;quot;__LINE__&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为了美化，warning message中可以使用&lt;code&gt;\n&lt;/code&gt;换行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，使用&lt;code&gt;FORMATTED_MESSAGE(MSG)&lt;/code&gt;宏就可以将带文件路径、序号、行数等信息加入到最终的warning中。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实到这步已经OK了，为了让这个宏更加抢眼，还可以借鉴RAC，把宏定义成前面加&lt;code&gt;@&lt;/code&gt;的形式：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define KEYWORDIFY try &amp;#123;&amp;#125; @catch (...) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将最终的宏定义前面加上上面的宏后，使用时就可以加&lt;code&gt;@&lt;/code&gt;前缀了（空的try-catch会被编译器优化，所以没啥性能损耗）&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;最终版本&quot;&gt;&lt;a href=&quot;#最终版本&quot; class=&quot;headerlink&quot; title=&quot;最终版本&quot;&gt;&lt;/a&gt;最终版本&lt;/h1&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define STRINGIFY(S) #S&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define DEFER_STRINGIFY(S) STRINGIFY(S)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define FORMATTED_MESSAGE(MSG) &lt;span class=&quot;meta-string&quot;&gt;&quot;[TODO-&quot;&lt;/span&gt; DEFER_STRINGIFY(__COUNTER__) &lt;span class=&quot;meta-string&quot;&gt;&quot;] &quot;&lt;/span&gt; MSG &lt;span class=&quot;meta-string&quot;&gt;&quot; \n&quot;&lt;/span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEFER_STRINGIFY(__FILE__) &lt;span class=&quot;string&quot;&gt;&quot; line &quot;&lt;/span&gt; DEFER_STRINGIFY(__LINE__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define KEYWORDIFY try &amp;#123;&amp;#125; @catch (...) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 最终使用下面的宏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define TODO(MSG) KEYWORDIFY PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h1 id=&quot;What’s-more&quot;&gt;&lt;a href=&quot;#What’s-more&quot; class=&quot;headerlink&quot; title=&quot;What’s more&quot;&gt;&lt;/a&gt;What’s more&lt;/h1&gt;&lt;p&gt;除此之外，还研究了半天如何在宏里面定义一个注释，这样就可以偷偷写&lt;code&gt;// TODO: ...&lt;/code&gt;的注释，让Xcode导航栏中也出现这个TODO了：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1eprhben4m9j20by02oglq.jpg&quot; width=&quot;300&quot;&gt;&lt;br&gt;但很可惜没有找到一个可行的方法，欢迎一起解决。&lt;br&gt;Xcode插件&lt;a href=&quot;https://github.com/trawor/XToDo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《XTodo》&lt;/a&gt;也是利用这个特性，可以尝试下。&lt;/p&gt;
&lt;p&gt;如果需要一个产生error的宏，将这里替换成这样就好了：&lt;code&gt;_Pragma(STRINGIFY(GCC error(MSG)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同时，上面的代码在&lt;a href=&quot;https://github.com/sunnyxx/TodoMacro&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《github上》&lt;/a&gt;可以找到。也欢迎关注微博&lt;a href=&quot;http://weibo.com/u/1364395395&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@我就叫Sunny怎么了&lt;/a&gt;一起交流。&lt;/p&gt;
&lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://clang.llvm.org/docs/UsersManual.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://clang.llvm.org/docs/UsersManual.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个能产生warning的TODO宏，用于在代码里做备忘，效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583jw1eprfhhfis1j20w004mju0.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;im
    
    </summary>
    
    
      <category term="wtf" scheme="http://blog.sunnyxx.com/tags/wtf/"/>
    
  </entry>
  
  <entry>
    <title>ARC对self的内存管理</title>
    <link href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/"/>
    <id>http://blog.sunnyxx.com/2015/01/17/self-in-arc/</id>
    <published>2015-01-17T02:59:56.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;记录下前两天的一次讨论，源于网络库&lt;strong&gt;YTKNetwork&lt;/strong&gt;中&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“YTKRequest.m”&lt;/a&gt;的&lt;code&gt;- start&lt;/code&gt;方法其中的几行代码：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)start &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ......&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YTKRequest *strongSelf = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [strongSelf.delegate requestFinished:strongSelf];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongSelf.successCompletionBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        strongSelf.successCompletionBlock(strongSelf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [strongSelf clearCompletionBlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看起来比较有违常理，所以和猿题库的@晨钰Lancy，@唐巧以及网易的@老汉一起讨论了下这个问题。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;具体的问题大概是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用方（如view controller）实例化并强引用&lt;code&gt;YTKRequest&lt;/code&gt;对象，将自己作为其delegate&lt;/li&gt;
&lt;li&gt;调用方调用&lt;code&gt;YTKRequest&lt;/code&gt;的&lt;code&gt;- start&lt;/code&gt;方法发起网络请求&lt;/li&gt;
&lt;li&gt;调用方在&lt;code&gt;- requestFinished:&lt;/code&gt;中执行了&lt;code&gt;self.request = nil;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YTKRequest&lt;/code&gt;中，&lt;code&gt;- start&lt;/code&gt;方法在回调完&lt;code&gt;- requestFinished:&lt;/code&gt;后&lt;strong&gt;BAD_ACCESS&lt;/strong&gt;了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，&lt;code&gt;- start&lt;/code&gt;方法还未返回时，self就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个&lt;code&gt;strongSelf&lt;/code&gt;的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。  &lt;/p&gt;
&lt;p&gt;简化说明就是：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// self被delegate持有&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.delegate callout]; &lt;span class=&quot;comment&quot;&gt;// 外部释放了这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这里self野指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《这篇ARC文档》&lt;/a&gt;中有明确的解释，总结如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARC下，self既不是strong也不是weak，而是&lt;code&gt;unsafe_unretained&lt;/code&gt;的，也就是说，入参的self被表示为：（init系列方法的self除外）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)start &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __unsafe_unretained YTKRequest *&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在方法调用时，ARC不会对self做retain或release，生命周期全由&lt;strong&gt;它的调用方来保证&lt;/strong&gt;，如果调用方没有保证，就会出现上面的crash&lt;/li&gt;
&lt;li&gt;ARC这样做的原因是&lt;strong&gt;性能优化&lt;/strong&gt;，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)start &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_retain(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 其中的代码self一定不会被释放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_release(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;优化了的性能还真是比较可观。&lt;br&gt;而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的&lt;strong&gt;命名约定&lt;/strong&gt;，通过判断方法是否以如&lt;code&gt;init&lt;/code&gt;，&lt;code&gt;alloc&lt;/code&gt;，&lt;code&gt;new&lt;/code&gt;，&lt;code&gt;copy&lt;/code&gt;等关键字开头来决定其内存管理方式。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;One more thing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在写test时发现，下面两种调用方法会导致不同结果：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_request start]; &lt;span class=&quot;comment&quot;&gt;// crash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.request start]; &lt;span class=&quot;comment&quot;&gt;// 正常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为&lt;code&gt;self.request&lt;/code&gt;是一次方法调用，返回的结果被&lt;code&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;方法在局部进行了一次强引用，关于这个方法可以看之前写过的关于Autorelease的&lt;a href=&quot;http://blog.sunnyxx.com/2014/10/15/behind-autorelease/&quot;&gt;《这篇文章》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录下前两天的一次讨论，源于网络库&lt;strong&gt;YTKNetwork&lt;/strong&gt;中&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKRequest.m&quot; target=
    
    </summary>
    
    
      <category term="objc刨根问底" scheme="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>64-bit Tips</title>
    <link href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/"/>
    <id>http://blog.sunnyxx.com/2014/12/20/64-bit-tips/</id>
    <published>2014-12-20T12:11:13.000Z</published>
    <updated>2016-04-16T00:52:10.000Z</updated>
    
    <content type="html">&lt;p&gt;终究还是来了。Apple下发了支持64位的最后通牒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。&lt;/p&gt;
&lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;h2 id=&quot;拒绝基本数据类型和隐式转换&quot;&gt;&lt;a href=&quot;#拒绝基本数据类型和隐式转换&quot; class=&quot;headerlink&quot; title=&quot;拒绝基本数据类型和隐式转换&quot;&gt;&lt;/a&gt;拒绝基本数据类型和隐式转换&lt;/h2&gt;&lt;p&gt;首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;size_t s1 = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t s2 = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t s3 = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t s4 = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;32-bit下：&lt;code&gt;4, 4, 4, 8&lt;/code&gt;；64-bit下：&lt;code&gt;4, 8, 4, 8&lt;/code&gt;&lt;br&gt;（PS： 这个结果随编译器，换其他平台可不一定）&lt;br&gt;它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现&lt;code&gt;sizeof&lt;/code&gt;的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int -&amp;gt; NSInteger&lt;/li&gt;
&lt;li&gt;unsigned -&amp;gt; NSUInteger&lt;/li&gt;
&lt;li&gt;float -&amp;gt; CGFloat&lt;/li&gt;
&lt;li&gt;动画时间 -&amp;gt; NSTimeInterval&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。&lt;/p&gt;
&lt;p&gt;再比如说下面的代码：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *items = @[@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;; i &amp;lt; items.count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%d&quot;&lt;/span&gt;, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果是，for循环一次都没有进。&lt;br&gt;数组的&lt;code&gt;count&lt;/code&gt;是&lt;code&gt;NSUInteger&lt;/code&gt;类型的，-1与其比较时隐式转换成&lt;code&gt;NSUInteger&lt;/code&gt;，变成了一个很大的数字：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(lldb) p i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(lldb) p (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;) $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;18446744073709551615&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）&lt;br&gt;老式for循环可以考虑写成：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index &amp;lt; items.count; index++) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，数组遍历还是更推荐用&lt;code&gt;for-in&lt;/code&gt;或&lt;code&gt;block&lt;/code&gt;版本的，它们之间的比较可以回顾下&lt;a href=&quot;http://blog.sunnyxx.com/2014/04/30/ios_iterator/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使用新版枚举&quot;&gt;&lt;a href=&quot;#使用新版枚举&quot; class=&quot;headerlink&quot; title=&quot;使用新版枚举&quot;&gt;&lt;/a&gt;使用新版枚举&lt;/h2&gt;&lt;p&gt;和上面的原因差不多，枚举应该使用新版的写法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationCurve&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationCurveEaseInOut&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationCurveEaseIn&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationCurveEaseOut&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationCurveLinear&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。&lt;/p&gt;
&lt;h2 id=&quot;替代Format字符串&quot;&gt;&lt;a href=&quot;#替代Format字符串&quot; class=&quot;headerlink&quot; title=&quot;替代Format字符串&quot;&gt;&lt;/a&gt;替代Format字符串&lt;/h2&gt;&lt;p&gt;适配64-bit时，你是否遇到了下面的恶心写法：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *items = @[@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;数组元素个数：%lu&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)items.count);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般情况下，利用&lt;code&gt;NSNumber&lt;/code&gt;的&lt;code&gt;@&lt;/code&gt;语法糖就可以解决：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *items = @[@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, @&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;数组元素个数：%@&quot;&lt;/span&gt;, @(items.count));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同理，int转string也可以：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10086&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string = @(i).stringValue;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，如需要&lt;code&gt;%.2f&lt;/code&gt;这种Format就不适用了。&lt;/p&gt;
&lt;h2 id=&quot;64-bit下的BOOL&quot;&gt;&lt;a href=&quot;#64-bit下的BOOL&quot; class=&quot;headerlink&quot; title=&quot;64-bit下的BOOL&quot;&gt;&lt;/a&gt;64-bit下的BOOL&lt;/h2&gt;&lt;p&gt;32-bit下，BOOL被定义为&lt;code&gt;signed char&lt;/code&gt;，@encode(BOOL)的结果是&lt;code&gt;&amp;#39;c&amp;#39;&lt;/code&gt;&lt;br&gt;64-bit下，BOOL被定义为&lt;code&gt;bool&lt;/code&gt;，@encode(BOOL)结果是&lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;&lt;br&gt;更直观的解释是：   &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(lldb) p/t (&lt;span class=&quot;keyword&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;) $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;b00000111 (&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(lldb) p/t (&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;) $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;b00000001 (&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像&lt;a href=&quot;http://www.bignerdranch.com/blog/bools-sharp-corners/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    &lt;/p&gt;
&lt;h2 id=&quot;不直接取isa指针&quot;&gt;&lt;a href=&quot;#不直接取isa指针&quot; class=&quot;headerlink&quot; title=&quot;不直接取isa指针&quot;&gt;&lt;/a&gt;不直接取isa指针&lt;/h2&gt;&lt;p&gt;编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的&lt;code&gt;object_getClass&lt;/code&gt; 和&lt;code&gt;object_setClass&lt;/code&gt;方法。关于64位下isa的讲解可以看&lt;a href=&quot;http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决第三方lib依赖和lipo命令&quot;&gt;&lt;a href=&quot;#解决第三方lib依赖和lipo命令&quot; class=&quot;headerlink&quot; title=&quot;解决第三方lib依赖和lipo命令&quot;&gt;&lt;/a&gt;解决第三方lib依赖和lipo命令&lt;/h2&gt;&lt;p&gt;以源码形式出现在工程中的第三方lib，只要把target加上&lt;code&gt;arm64&lt;/code&gt;编译就好了。&lt;br&gt;恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  &lt;/p&gt;
&lt;h3 id=&quot;打印Mach-O文件支持的架构&quot;&gt;&lt;a href=&quot;#打印Mach-O文件支持的架构&quot; class=&quot;headerlink&quot; title=&quot;打印Mach-O文件支持的架构&quot;&gt;&lt;/a&gt;打印Mach-O文件支持的架构&lt;/h3&gt;&lt;p&gt;如何看一个可执行文件是不是支持64-bit呢？   &lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;lipo -info&lt;/code&gt;命令，比如看看UIKit支持的架构：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当前在Xcode Frameworks目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sunnyxx$ lipo -info &lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;.framework/&lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Architectures &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the fat file: &lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;.framework/&lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt; are: arm64 armv7s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;想看的更详细的信息可以使用&lt;code&gt;lipo -detailed_info&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sunnyxx$ lipo -detailed_info &lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;.framework/&lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fat header &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;.framework/&lt;span class=&quot;built_in&quot;&gt;UIKit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fat_magic &lt;span class=&quot;number&quot;&gt;0xcafebabe&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nfat_arch &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;architecture arm64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cputype CPU_TYPE_ARM64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cpusubtype CPU_SUBTYPE_ARM64_ALL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    offset &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size &lt;span class=&quot;number&quot;&gt;16822272&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    align &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;architecture armv7s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cputype CPU_TYPE_ARM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cpusubtype CPU_SUBTYPE_ARM_V7S&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    offset &lt;span class=&quot;number&quot;&gt;16826368&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size &lt;span class=&quot;number&quot;&gt;14499840&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    align &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，还可以使用&lt;code&gt;file&lt;/code&gt;命令：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sunnyxx$ file UIKit.framework/UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIKit.framework/UIKit: Mach-O universal binary with 2 architectures&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述命令对&lt;code&gt;Mach-O&lt;/code&gt;文件适用，静态库&lt;code&gt;.a&lt;/code&gt;文件，framework中的&lt;code&gt;.a&lt;/code&gt;文件，自己app的可执行文件都可以打印下看看。  &lt;/p&gt;
&lt;h3 id=&quot;合并多个架构的包&quot;&gt;&lt;a href=&quot;#合并多个架构的包&quot; class=&quot;headerlink&quot; title=&quot;合并多个架构的包&quot;&gt;&lt;/a&gt;合并多个架构的包&lt;/h3&gt;&lt;p&gt;如果，我们有&lt;code&gt;MyLib-32.a&lt;/code&gt;和&lt;code&gt;MyLib-64.a&lt;/code&gt;，可以使用&lt;code&gt;lipo -create&lt;/code&gt;命令合并：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;支持64-bit后程序包会变大么？&quot;&gt;&lt;a href=&quot;#支持64-bit后程序包会变大么？&quot; class=&quot;headerlink&quot; title=&quot;支持64-bit后程序包会变大么？&quot;&gt;&lt;/a&gt;支持64-bit后程序包会变大么？&lt;/h2&gt;&lt;p&gt;会，支持64-bit后，多了一个&lt;code&gt;arm64&lt;/code&gt;架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。&lt;/p&gt;
&lt;h2 id=&quot;一个lib包含了很多的架构，会打到最后的包里么？&quot;&gt;&lt;a href=&quot;#一个lib包含了很多的架构，会打到最后的包里么？&quot; class=&quot;headerlink&quot; title=&quot;一个lib包含了很多的架构，会打到最后的包里么？&quot;&gt;&lt;/a&gt;一个lib包含了很多的架构，会打到最后的包里么？&lt;/h2&gt;&lt;p&gt;不会，如果lib中有&lt;code&gt;armv7, armv7s, arm64, i386&lt;/code&gt;架构，而target architecture选择了&lt;code&gt;armv7s, arm64&lt;/code&gt;，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。&lt;/p&gt;
&lt;h2 id=&quot;Checklist&quot;&gt;&lt;a href=&quot;#Checklist&quot; class=&quot;headerlink&quot; title=&quot;Checklist&quot;&gt;&lt;/a&gt;Checklist&lt;/h2&gt;&lt;p&gt;最后列一下官方文档中的注意点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要将指针强转成整数&lt;/li&gt;
&lt;li&gt;程序各处使用统一的数据类型&lt;/li&gt;
&lt;li&gt;对不同类型的整数做运算时一定要注意&lt;/li&gt;
&lt;li&gt;需要定长变量时，使用如&lt;code&gt;int32_t, int64_t&lt;/code&gt;这种定长类型&lt;/li&gt;
&lt;li&gt;使用malloc时，不要写死size&lt;/li&gt;
&lt;li&gt;使用能同时适配两个架构的格式化字符串&lt;/li&gt;
&lt;li&gt;注意函数和函数指针（类型转换和可变参数）&lt;/li&gt;
&lt;li&gt;不要直接访问Objective-C的指针（isa）&lt;/li&gt;
&lt;li&gt;使用内建的同步原语（Primitives）&lt;/li&gt;
&lt;li&gt;不要硬编码虚存页大小&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go Position Independent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.bignerdranch.com/blog/64-bit-smorgasbord/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.bignerdranch.com/blog/64-bit-smorgasbord/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.bignerdranch.com/blog/bools-sharp-corners/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.bignerdranch.com/blog/bools-sharp-corners/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;终究还是来了。Apple下发了支持64位的最后通牒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App S
    
    </summary>
    
    
      <category term="ios最佳实践" scheme="http://blog.sunnyxx.com/tags/ios%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>从NSArray看类簇</title>
    <link href="http://blog.sunnyxx.com/2014/12/18/class-cluster/"/>
    <id>http://blog.sunnyxx.com/2014/12/18/class-cluster/</id>
    <published>2014-12-18T14:22:22.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Class-Clusters&quot;&gt;&lt;a href=&quot;#Class-Clusters&quot; class=&quot;headerlink&quot; title=&quot;Class Clusters&quot;&gt;&lt;/a&gt;Class Clusters&lt;/h1&gt;&lt;p&gt;Class Clusters（类簇）是&lt;code&gt;抽象工厂&lt;/code&gt;模式在iOS下的一种实现，众多常用类，如&lt;code&gt;NSString&lt;/code&gt;，&lt;code&gt;NSArray&lt;/code&gt;，&lt;code&gt;NSDictionary&lt;/code&gt;，&lt;code&gt;NSNumber&lt;/code&gt;都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。&lt;/p&gt;
&lt;h1 id=&quot;NSArray的类簇&quot;&gt;&lt;a href=&quot;#NSArray的类簇&quot; class=&quot;headerlink&quot; title=&quot;NSArray的类簇&quot;&gt;&lt;/a&gt;NSArray的类簇&lt;/h1&gt;&lt;p&gt;虽然&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;中拿&lt;code&gt;NSNumber&lt;/code&gt;说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下&lt;code&gt;NSArray&lt;/code&gt;类簇的实现方式。  &lt;/p&gt;
&lt;h2 id=&quot;NSPlacehodlerArray&quot;&gt;&lt;a href=&quot;#NSPlacehodlerArray&quot; class=&quot;headerlink&quot; title=&quot;__NSPlacehodlerArray&quot;&gt;&lt;/a&gt;__NSPlacehodlerArray&lt;/h2&gt;&lt;p&gt;熟悉这个模式的同学很可能看过下面的测试代码，将原有的&lt;code&gt;alloc+init&lt;/code&gt;拆开写：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1 = [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; alloc]; &lt;span class=&quot;comment&quot;&gt;// __NSPlacehodlerArray *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj2 = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc];  &lt;span class=&quot;comment&quot;&gt;// __NSPlacehodlerArray *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj3 = [obj1 init];  &lt;span class=&quot;comment&quot;&gt;// __NSArrayI *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj4 = [obj2 init];  &lt;span class=&quot;comment&quot;&gt;// __NSArrayM *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发现&lt;code&gt;+ alloc&lt;/code&gt;后并非生成了我们期望的类实例，而是一个&lt;code&gt;__NSPlacehodlerArray&lt;/code&gt;的中间对象，后面的&lt;code&gt;- init&lt;/code&gt;或&lt;code&gt;- initWithXXXXX&lt;/code&gt;消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的&lt;code&gt;__NSArrayI&lt;/code&gt;和&lt;code&gt;__NSArrayM&lt;/code&gt;分别对应Immutable和Mutable（后面的I和M的意思）&lt;/p&gt;
&lt;p&gt;于是顺着思路猜实现，&lt;code&gt;__NSPlacehodlerArray&lt;/code&gt;必定用某种方式存储了&lt;strong&gt;它是由谁alloc出来的&lt;/strong&gt;这个信息，才能在&lt;code&gt;init&lt;/code&gt;的时候知道要创建的是可变数组还是不可变数组&lt;/p&gt;
&lt;p&gt;于是乎很开心的去看了下&lt;code&gt;*obj1&lt;/code&gt;的内存布局：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg&quot; width=&quot;404&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是&lt;code&gt;*obj1&lt;/code&gt;，第二个是&lt;code&gt;*obj2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg&quot; width=&quot;404&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的&lt;code&gt;0x0051E768&lt;/code&gt;就是&lt;code&gt;__NSPlacehodlerArray&lt;/code&gt;类对象地址，可以从lldb下&lt;code&gt;po&lt;/code&gt;这个地址来验证。&lt;/p&gt;
&lt;p&gt;那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？&lt;br&gt;经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; *GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; *instanceFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!instanceFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        instanceFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; = [[__&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instanceFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; *GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; *instanceFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!instanceFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        instanceFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; = [[__&lt;span class=&quot;built_in&quot;&gt;NSPlacehodlerArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instanceFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// NSArray实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)alloc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; == [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; class]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// NSMutableArray实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)alloc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; == [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; class]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// __NSPlacehodlerArray实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; == GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [[__&lt;span class=&quot;built_in&quot;&gt;NSArrayI&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; == GetPlaceholderFor&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [[__&lt;span class=&quot;built_in&quot;&gt;NSArrayM&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Foundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1 = [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; alloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj2 = [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; alloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj3 = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj4 = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;静态不可变空对象&quot;&gt;&lt;a href=&quot;#静态不可变空对象&quot; class=&quot;headerlink&quot; title=&quot;静态不可变空对象&quot;&gt;&lt;/a&gt;静态不可变空对象&lt;/h1&gt;&lt;p&gt;除此之外，Foundation对&lt;code&gt;不可变&lt;/code&gt;版本的空数组也做了个小优化：  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arr1 = [[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; alloc] init];
&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arr2 = [[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; alloc] init];
&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arr3 = @[];
&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arr4 = @[];
&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arr5 = @[@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边1-4号都指向了同一个对象，而arr5指向了另一个对象。&lt;br&gt;若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。&lt;br&gt;不仅是NSArray，Foundation中如&lt;code&gt;NSString&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的&lt;code&gt;@&amp;quot;&amp;quot;&lt;/code&gt;）  &lt;/p&gt;
&lt;p&gt;所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。&lt;/p&gt;
&lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://iphonedevwiki.net/index.php/Foundation.framework/Inheritance_hierarchy&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Class-Clusters&quot;&gt;&lt;a href=&quot;#Class-Clusters&quot; class=&quot;headerlink&quot; title=&quot;Class Clusters&quot;&gt;&lt;/a&gt;Class Clusters&lt;/h1&gt;&lt;p&gt;Class Clusters（类簇）是&lt;co
    
    </summary>
    
    
      <category term="objc刨根问底" scheme="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>神经病院objc runtime入院考试</title>
    <link href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/"/>
    <id>http://blog.sunnyxx.com/2014/11/06/runtime-nuts/</id>
    <published>2014-11-06T15:07:21.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）&lt;/li&gt;
&lt;li&gt;这几个题分别对应了runtime中几个隐蔽的知识点，挺非主流的，没必要深究&lt;/li&gt;
&lt;li&gt;答案在本页末尾给出，有同学针对这几道题写了讲解，所以就一笔带过了&lt;/li&gt;
&lt;li&gt;分享的具体内容争取找个时间写个blog总结下&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;神经病院objc-runtime入院考试&quot;&gt;&lt;a href=&quot;#神经病院objc-runtime入院考试&quot; class=&quot;headerlink&quot; title=&quot;神经病院objc runtime入院考试&quot;&gt;&lt;/a&gt;神经病院objc runtime入院考试&lt;/h1&gt;&lt;p&gt;(1) 下面的代码输出什么？  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Son&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Father&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2) 下面代码的结果？  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res1 = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; class] isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; class]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res2 = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; class] isMemberOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; class]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res3 = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)[Sark class] isKindOfClass:[Sark class]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res4 = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)[Sark class] isMemberOfClass:[Sark class]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(3) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;IMP: -[NSObject (Sark) foo]&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 测试代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; foo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new] foo];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(4) 下面的代码会？Compile Error / Runtime Crash / NSLog…?  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sark&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)speak &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;my name&#39;s %@&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; cls = [Sark class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj = &amp;amp;cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj speak];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h1&gt;&lt;p&gt;(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成&lt;code&gt;objc_msgSendSuper&lt;/code&gt;，但仍以self作为reveiver&lt;br&gt;(2) YES / NO / NO / NO &lt;code&gt;&amp;lt;NSObject&amp;gt;&lt;/code&gt;协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES&lt;br&gt;(3) 编译运行正常，两行代码都执行&lt;code&gt;-foo&lt;/code&gt;。 [NSObject foo]方法查找路线为 NSObject meta class –super-&amp;gt; NSObject class，和第二题知识点很相似。&lt;br&gt;(4)编译运行正常，输出ViewController中的&lt;code&gt;self&lt;/code&gt;对象。 编译运行正常，调用了&lt;code&gt;-speak&lt;/code&gt;方法，由于&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; cls = [Sark class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *obj = &amp;amp;cls;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;obj&lt;/code&gt;已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），遂能够正常走消息机制；&lt;br&gt;由于这个人造的对象在栈上，而取&lt;code&gt;self.name&lt;/code&gt;的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;《神经病眼中的objc runtime》北京线下分享活动顺利完成，为了配合讲解编造的几个runtime考题发出来分享下：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为分享内容配合讲解用，可不是为了面试别人的哦（容易被抽）&lt;/li&gt;
&lt;li&gt;这几个题分别对应了runtime中几个隐蔽的知
    
    </summary>
    
    
      <category term="wtf" scheme="http://blog.sunnyxx.com/tags/wtf/"/>
    
  </entry>
  
  <entry>
    <title>黑幕背后的Autorelease</title>
    <link href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/"/>
    <id>http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</id>
    <published>2014-10-15T14:48:05.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用&lt;code&gt;[obj autorelease]&lt;/code&gt;来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。&lt;/p&gt;
&lt;h1 id=&quot;Autorelease对象什么时候释放？&quot;&gt;&lt;a href=&quot;#Autorelease对象什么时候释放？&quot; class=&quot;headerlink&quot; title=&quot;Autorelease对象什么时候释放？&quot;&gt;&lt;/a&gt;Autorelease对象什么时候释放？&lt;/h1&gt;&lt;p&gt;这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。&lt;br&gt;在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的&lt;code&gt;runloop&lt;/code&gt;迭代结束时释放的，而它能够释放的原因是&lt;strong&gt;系统在每个runloop迭代中都加入了自动释放池Push和Pop&lt;/strong&gt;  &lt;/p&gt;
&lt;h2 id=&quot;小实验&quot;&gt;&lt;a href=&quot;#小实验&quot; class=&quot;headerlink&quot; title=&quot;小实验&quot;&gt;&lt;/a&gt;小实验&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; reference = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;sunnyxx&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// str是一个autorelease对象，设置一个weak的引用来观察它&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reference = str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewWillAppear:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, reference); &lt;span class=&quot;comment&quot;&gt;// Console: sunnyxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidAppear:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, reference); &lt;span class=&quot;comment&quot;&gt;// Console: (null)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;del&gt;这个实验同时也证明了&lt;code&gt;viewDidLoad&lt;/code&gt;和&lt;code&gt;viewWillAppear&lt;/code&gt;是在同一个runloop调用的，而&lt;code&gt;viewDidAppear&lt;/code&gt;是在之后的某个runloop调用的。&lt;/del&gt;&lt;br&gt;由于这个vc在loadView之后便add到了window层级上，所以&lt;code&gt;viewDidLoad&lt;/code&gt;和&lt;code&gt;viewWillAppear&lt;/code&gt;是在同一个runloop调用的，因此在&lt;code&gt;viewWillAppear&lt;/code&gt;中，这个autorelease的变量依然有值。  &lt;/p&gt;
&lt;p&gt;当然，我们也可以手动干预Autorelease对象的释放时机：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;sunnyxx&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, str); &lt;span class=&quot;comment&quot;&gt;// Console: (null)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Autorelease原理&quot;&gt;&lt;a href=&quot;#Autorelease原理&quot; class=&quot;headerlink&quot; title=&quot;Autorelease原理&quot;&gt;&lt;/a&gt;Autorelease原理&lt;/h1&gt;&lt;h2 id=&quot;AutoreleasePoolPage&quot;&gt;&lt;a href=&quot;#AutoreleasePoolPage&quot; class=&quot;headerlink&quot; title=&quot;AutoreleasePoolPage&quot;&gt;&lt;/a&gt;AutoreleasePoolPage&lt;/h2&gt;&lt;p&gt;ARC下，我们使用&lt;code&gt;@autoreleasepool{}&lt;/code&gt;来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void *context = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#123;&amp;#125;中的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(context);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这两个函数都是对&lt;code&gt;AutoreleasePoolPage&lt;/code&gt;的简单封装，所以自动释放机制的核心就在于这个类。  &lt;/p&gt;
&lt;p&gt;AutoreleasePoolPage是一个C++实现的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以&lt;code&gt;双向链表&lt;/code&gt;的形式组合而成（分别对应结构中的parent指针和child指针）&lt;/li&gt;
&lt;li&gt;AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）&lt;/li&gt;
&lt;li&gt;AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址&lt;/li&gt;
&lt;li&gt;上面的&lt;code&gt;id *next&lt;/code&gt;指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置&lt;/li&gt;
&lt;li&gt;一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的&lt;code&gt;next&lt;/code&gt;指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，向一个对象发送&lt;code&gt;- autorelease&lt;/code&gt;消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;释放时刻&quot;&gt;&lt;a href=&quot;#释放时刻&quot; class=&quot;headerlink&quot; title=&quot;释放时刻&quot;&gt;&lt;/a&gt;释放时刻&lt;/h2&gt;&lt;p&gt;每当进行一次&lt;code&gt;objc_autoreleasePoolPush&lt;/code&gt;调用时，runtime向当前的AutoreleasePoolPage中add进一个&lt;code&gt;哨兵对象&lt;/code&gt;，值为0（也就是个nil），那么这一个page就变成了下面的样子：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_autoreleasePoolPush&lt;/code&gt;的返回值正是这个哨兵对象的地址，被&lt;code&gt;objc_autoreleasePoolPop(哨兵对象)&lt;/code&gt;作为入参，于是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据传入的哨兵对象地址找到哨兵对象所处的page&lt;/li&gt;
&lt;li&gt;在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次&lt;code&gt;- release&lt;/code&gt;消息，并向回移动&lt;code&gt;next&lt;/code&gt;指针到正确位置&lt;/li&gt;
&lt;li&gt;补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;嵌套的AutoreleasePool&quot;&gt;&lt;a href=&quot;#嵌套的AutoreleasePool&quot; class=&quot;headerlink&quot; title=&quot;嵌套的AutoreleasePool&quot;&gt;&lt;/a&gt;嵌套的AutoreleasePool&lt;/h2&gt;&lt;p&gt;知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;【附加内容】&lt;/p&gt;
&lt;h1 id=&quot;Autorelease返回值的快速释放机制&quot;&gt;&lt;a href=&quot;#Autorelease返回值的快速释放机制&quot; class=&quot;headerlink&quot; title=&quot;Autorelease返回值的快速释放机制&quot;&gt;&lt;/a&gt;Autorelease返回值的快速释放机制&lt;/h1&gt;&lt;p&gt;值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。&lt;br&gt;比如一个工厂方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)createSark &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// caller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sark *sark = [Sark createSark];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)createSark &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autoreleaseReturnValue(tmp); &lt;span class=&quot;comment&quot;&gt;// 代替我们调用autorelease&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// caller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) &lt;span class=&quot;comment&quot;&gt;// 代替我们调用retain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sark *sark = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeStrong(&amp;amp;sark, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 相当于代替我们调用了release&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。&lt;/p&gt;
&lt;h2 id=&quot;黑魔法之Thread-Local-Storage&quot;&gt;&lt;a href=&quot;#黑魔法之Thread-Local-Storage&quot; class=&quot;headerlink&quot; title=&quot;黑魔法之Thread Local Storage&quot;&gt;&lt;/a&gt;黑魔法之Thread Local Storage&lt;/h2&gt;&lt;p&gt;Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* pthread_getspecific(pthread_key_t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pthread_setspecific(pthread_key_t , &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说它是黑魔法可能被懂pthread的笑话- -  &lt;/p&gt;
&lt;p&gt;在返回值身上调用&lt;code&gt;objc_autoreleaseReturnValue&lt;/code&gt;方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的&lt;code&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。&lt;br&gt;于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。  &lt;/p&gt;
&lt;p&gt;于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）&lt;br&gt;只能动用更高级的黑魔法。  &lt;/p&gt;
&lt;h2 id=&quot;黑魔法之-builtin-return-address&quot;&gt;&lt;a href=&quot;#黑魔法之-builtin-return-address&quot; class=&quot;headerlink&quot; title=&quot;黑魔法之__builtin_return_address&quot;&gt;&lt;/a&gt;黑魔法之__builtin_return_address&lt;/h2&gt;&lt;p&gt;这个内建函数原型是&lt;code&gt;char *__builtin_return_address(int level)&lt;/code&gt;，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%p&quot;&lt;/span&gt;, __builtin_return_address(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 根据这个地址能找到下面ret的地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// caller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = [sark foo];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）&lt;br&gt;也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。&lt;br&gt;回到上面的问题，&lt;strong&gt;如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;黑魔法之反查汇编指令&quot;&gt;&lt;a href=&quot;#黑魔法之反查汇编指令&quot; class=&quot;headerlink&quot; title=&quot;黑魔法之反查汇编指令&quot;&gt;&lt;/a&gt;黑魔法之反查汇编指令&lt;/h2&gt;&lt;p&gt;通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的&lt;code&gt;汇编指令&lt;/code&gt;：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// caller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = [sark foo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;movq ??? ???&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;callq ???&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。&lt;br&gt;于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; callerAcceptsFastAutorelease(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ra0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *ra1 = (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint8_t *)ra0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint16_t *ra2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint32_t *ra4 = (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint32_t *)ra1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **sym;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 48 89 c7    movq  %rax,%rdi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// e8          callq symbol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*ra4 != &lt;span class=&quot;number&quot;&gt;0xe8c78948&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ra1 += (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)*(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; int32_t *)(ra1 + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ra2 = (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uint16_t *)ra1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ff 25       jmpq *symbol@DYLDMAGIC(%rip)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*ra2 != &lt;span class=&quot;number&quot;&gt;0x25ff&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ra1 += &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;l + (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)*(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; int32_t *)(ra1 + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sym = (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **)ra1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*sym != objc_retainAutoreleasedReturnValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它检验了主调方在返回值之后是否紧接着调用了&lt;code&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。&lt;/p&gt;
&lt;h1 id=&quot;其他Autorelease相关知识点&quot;&gt;&lt;a href=&quot;#其他Autorelease相关知识点&quot; class=&quot;headerlink&quot; title=&quot;其他Autorelease相关知识点&quot;&gt;&lt;/a&gt;其他Autorelease相关知识点&lt;/h1&gt;&lt;p&gt;使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[array enumerateObjectsUsingBlock:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj, &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; idx, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这里被一个局部@autoreleasepool包围着&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用&lt;code&gt;[obj autorelease]&lt;
    
    </summary>
    
    
      <category term="objc刨根问底" scheme="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>( ) -&gt; ( )</title>
    <link href="http://blog.sunnyxx.com/2014/10/14/fp-essential/"/>
    <id>http://blog.sunnyxx.com/2014/10/14/fp-essential/</id>
    <published>2014-10-14T11:44:42.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;() -&amp;gt; ()&lt;/code&gt;不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即&lt;code&gt;值&lt;/code&gt;的变化过程。本文将从&lt;code&gt;swift&lt;/code&gt;语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观。随后分享一个&lt;code&gt;Reactive Cocoa&lt;/code&gt;作者的Talk中的编程思想。&lt;/p&gt;
&lt;h1 id=&quot;编程的核心&quot;&gt;&lt;a href=&quot;#编程的核心&quot; class=&quot;headerlink&quot; title=&quot;编程的核心&quot;&gt;&lt;/a&gt;编程的核心&lt;/h1&gt;&lt;p&gt;编程的无非两件事，&lt;code&gt;数据&lt;/code&gt;和&lt;code&gt;运算&lt;/code&gt;。&lt;br&gt;放在计算机硬件，是内存和CPU；&lt;br&gt;放在C语言，是结构体和函数（基本类型本质上就是一个只有一个字段的结构体）；&lt;br&gt;放在面向对象的语言，是类和消息；&lt;br&gt;放在函数式语言，就是值和函数了&lt;/p&gt;
&lt;p&gt;如果用&lt;code&gt;()&lt;/code&gt;表示数据，&lt;code&gt;-&amp;gt;&lt;/code&gt;表示运算，也是醉了&lt;/p&gt;
&lt;h1 id=&quot;从Swift说起&quot;&gt;&lt;a href=&quot;#从Swift说起&quot; class=&quot;headerlink&quot; title=&quot;从Swift说起&quot;&gt;&lt;/a&gt;从Swift说起&lt;/h1&gt;&lt;h2 id=&quot;gt-表示运算过程&quot;&gt;&lt;a href=&quot;#gt-表示运算过程&quot; class=&quot;headerlink&quot; title=&quot;-&amp;gt;表示运算过程&quot;&gt;&lt;/a&gt;-&amp;gt;表示运算过程&lt;/h2&gt;&lt;p&gt;熟悉swift的同学肯定能联想到swift中函数的表示方法&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(number: Int)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f = foo &lt;span class=&quot;comment&quot;&gt;// f的类型为 (Int) -&amp;gt; Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把参数通通去掉之后就成了&lt;code&gt;() -&amp;gt; ()&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;像好多吐槽swift语法的人一样，起初我也不理解为什么用这么个奇葩的&lt;code&gt;-&amp;gt;&lt;/code&gt;来表示返回值，其实它并非表示返回值，而是表示&lt;code&gt;运算过程&lt;/code&gt;，从入参到返回值的过程。按这个思路来看，把返回值写在函数声明前面倒是有点说不通了。&lt;/p&gt;
&lt;h2 id=&quot;元组表示所有的值&quot;&gt;&lt;a href=&quot;#元组表示所有的值&quot; class=&quot;headerlink&quot; title=&quot;元组表示所有的值&quot;&gt;&lt;/a&gt;元组表示所有的值&lt;/h2&gt;&lt;p&gt;再来说说这个&lt;code&gt;()&lt;/code&gt;，在swift里面表示元组（tuple），值得一提的是，swift里面任何值都是一个tuple，且一共有三种Tuple：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;0-Tuple&lt;/strong&gt;表示空值，也就是&lt;code&gt;Void&lt;/code&gt; （Void是&lt;code&gt;()&lt;/code&gt;的别名）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;1-Tuple&lt;/strong&gt;表示任意一个类型的实例（Int、String、对象、枚举等等），也就是说&lt;code&gt;Int&lt;/code&gt;其实是一个&lt;code&gt;(Int)&lt;/code&gt;，&lt;code&gt;String&lt;/code&gt;是一个&lt;code&gt;(String)&lt;/code&gt;，以此类推，所以有下面的写法：&lt;/p&gt;
  &lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;N-Tuple&lt;/strong&gt;表示两个以上值的组合，如&lt;code&gt;(2, &amp;quot;B&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;func是一种特殊的block&quot;&gt;&lt;a href=&quot;#func是一种特殊的block&quot; class=&quot;headerlink&quot; title=&quot;func是一种特殊的block&quot;&gt;&lt;/a&gt;func是一种特殊的block&lt;/h2&gt;&lt;p&gt;一开始我认为block是一种特殊的func，后来发现反过来理解更加合理。  &lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i: Int)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f = &lt;span class=&quot;type&quot;&gt;Foo&lt;/span&gt;.bar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中f的类型为&lt;code&gt;Foo -&amp;gt; (Int) -&amp;gt; ()&lt;/code&gt;，用括号结合一下更好理解：&lt;code&gt;Foo -&amp;gt; (Int -&amp;gt; ())&lt;/code&gt;，外层传入一个Foo的实例，返回值是一个&lt;code&gt;(Int) -&amp;gt; ()&lt;/code&gt;的函数&lt;/p&gt;
&lt;p&gt;知道这一点，上面的方法用一个block也能轻松搞定：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &amp;#123;(f: &lt;span class=&quot;type&quot;&gt;Foo&lt;/span&gt;) -&amp;gt; (&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) -&amp;gt; () &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;(i: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以说，一个&lt;code&gt;func&lt;/code&gt;只是在一个&lt;code&gt;class&lt;/code&gt;（或struct、enum）作用域中一个特殊的block罢了，隐式的被传入了第一层的&lt;code&gt;self&lt;/code&gt;参数而已。再多想一步，假如外部有一个全局变量，在&lt;code&gt;func&lt;/code&gt;中是可以访问，多么像block的捕获外部变量呢。&lt;/p&gt;
&lt;h2 id=&quot;swift函数式世界观&quot;&gt;&lt;a href=&quot;#swift函数式世界观&quot; class=&quot;headerlink&quot; title=&quot;swift函数式世界观&quot;&gt;&lt;/a&gt;swift函数式世界观&lt;/h2&gt;&lt;p&gt;讲到这儿，swift中的&lt;code&gt;数据&lt;/code&gt;+&lt;code&gt;运算&lt;/code&gt;就可以被抽象成：&lt;code&gt;() -&amp;gt; ()&lt;/code&gt;了，一切结构、函数、block，各种调用，本质上都可以被归纳成&lt;strong&gt;从一个元组经过运算得到另一个元组的过程&lt;/strong&gt;，这不就是&lt;code&gt;函数式编程&lt;/code&gt;么。&lt;br&gt;当然，这个思想也不孤单，&lt;code&gt;java script&lt;/code&gt;中也用&lt;code&gt;=&amp;gt;&lt;/code&gt;来表示相同的概念&lt;/p&gt;
&lt;h1 id=&quot;Reactive-Cocoa作者谈未来&quot;&gt;&lt;a href=&quot;#Reactive-Cocoa作者谈未来&quot; class=&quot;headerlink&quot; title=&quot;Reactive Cocoa作者谈未来&quot;&gt;&lt;/a&gt;Reactive Cocoa作者谈未来&lt;/h1&gt;&lt;p&gt;说完了swift，再来说&lt;code&gt;Reactive Cocoa&lt;/code&gt;&lt;br&gt;RAC可以说是对objc语言和runtime机制使用最深刻的开源库之一了，可见作者对水平。他的&lt;code&gt;《The Future of Reactive Cocoa》&lt;/code&gt;的Talk很有趣，pdf可以从&lt;a href=&quot;https://github.com/jspahrsummers/the-future-of-reactivecocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个git地址下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他把函数式编程中的Event分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Observer（Push）: &lt;code&gt;Event -&amp;gt; ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Obserable（Push）: &lt;code&gt;(Event -&amp;gt; ()) -&amp;gt; ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Enumerator（Pull）: &lt;code&gt;() -&amp;gt; Event&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Enumerable（Pull）: &lt;code&gt;() -&amp;gt; (() -&amp;gt; Event)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先不说具体含义，这个抽象范式的表示方法就与上面提到一致。熟悉RAC的同学将会对上面精简的概括叫绝。&lt;br&gt;拿第二个，Obserable来说，这就是RAC中的&lt;code&gt;RACSignal&lt;/code&gt;，后面的范式表示这个Event可以串联起来（当返回值的也是一个同样结构的函数时）：&lt;br&gt;&lt;code&gt;(Event1 -&amp;gt; ()) -&amp;gt; (Event2 -&amp;gt; ()) -&amp;gt;...-&amp;gt; (EventN -&amp;gt; ()) -&amp;gt; ()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;不寻常意义的Enumerator&quot;&gt;&lt;a href=&quot;#不寻常意义的Enumerator&quot; class=&quot;headerlink&quot; title=&quot;不寻常意义的Enumerator&quot;&gt;&lt;/a&gt;不寻常意义的Enumerator&lt;/h2&gt;&lt;p&gt;这里的Enumerator不是通常意义上的&lt;code&gt;for-in&lt;/code&gt;语句中使用的枚举器，而是代表了一种&lt;code&gt;延时计算&lt;/code&gt;的思想：不到最后一刻，这个值一直不被计算出来，向它套用的函数也都将延时到最后才依次计算。其实swift在语言基本库中就实现了它，名为&lt;code&gt;LazyBidirectionalCollection&lt;/code&gt;，如一个字典：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dict = [&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; generator = dict.keys.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(&amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.lowercaseString&amp;#125;).generate()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generator.next()! &lt;span class=&quot;comment&quot;&gt;// &quot;b&quot; （这里进行一次计算）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generator.next()! &lt;span class=&quot;comment&quot;&gt;// &quot;a&quot; （这里进行后一次计算）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;跑题了，往回拉拉&quot;&gt;&lt;a href=&quot;#跑题了，往回拉拉&quot; class=&quot;headerlink&quot; title=&quot;跑题了，往回拉拉&quot;&gt;&lt;/a&gt;跑题了，往回拉拉&lt;/h1&gt;&lt;p&gt;&lt;code&gt;()&lt;/code&gt;表示任意的值&lt;br&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;表示运算过程&lt;br&gt;所以&lt;code&gt;() -&amp;gt; ()&lt;/code&gt;表示一个任意的函数  &lt;/p&gt;
&lt;p&gt;函数作为一等公民，可以作为值进行传递，所以上面的范式中的值也可以是函数，于是衍生出&lt;br&gt;&lt;code&gt;(() -&amp;gt; ()) -&amp;gt; ()&lt;/code&gt;或&lt;code&gt;() -&amp;gt; (() -&amp;gt; ())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这就是函数式编程&lt;/p&gt;
&lt;h1 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://medium.com/swift-programming/facets-of-swift-part-2-tuples-4bfe58d21abf&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/jspahrsummers/the-future-of-reactivecocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/jspahrsummers/the-future-of-reactivecocoa&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我是前言&quot;&gt;&lt;a href=&quot;#我是前言&quot; class=&quot;headerlink&quot; title=&quot;我是前言&quot;&gt;&lt;/a&gt;我是前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;() -&amp;gt; ()&lt;/code&gt;不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，
    
    </summary>
    
    
      <category term="wtf" scheme="http://blog.sunnyxx.com/tags/wtf/"/>
    
  </entry>
  
  <entry>
    <title>黑魔法__attribute__((cleanup))</title>
    <link href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/"/>
    <id>http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/</id>
    <published>2014-09-15T09:09:36.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;p&gt;编译器属性&lt;code&gt;__attribute__&lt;/code&gt;用于向编译器描述特殊的标识、检查或优化，几个常用的用法看&lt;a href=&quot;http://nshipster.com/__attribute__/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《mattt大神的文章》&lt;/a&gt;就好。今天发现一个名为&lt;code&gt;cleanup&lt;/code&gt;的黑魔法属性，简单介绍下。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__attribute__((cleanup(...)))&lt;/code&gt;，用于修饰一个变量，&lt;strong&gt;在它的作用域结束时可以自动执行一个指定的方法&lt;/strong&gt;，如：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; stringCleanUp(__&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; **string) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, *string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在某个方法中：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string __attribute__((cleanup(stringCleanUp))) = &lt;span class=&quot;string&quot;&gt;@&quot;sunnyxx&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// 当运行到这个作用域结束时，自动调用stringCleanUp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。&lt;br&gt;当然，可以修饰的变量不止NSString，&lt;code&gt;自定义Class&lt;/code&gt;或&lt;code&gt;基本类型&lt;/code&gt;都是可以的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自定义的Class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; sarkCleanUp(__&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; Sark **sark) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, *sark);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基本类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; intCleanUp(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; *integer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%d&quot;&lt;/span&gt;, *integer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; integer __attribute__((cleanup(intCleanUp))) = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如一个作用域内有若干个cleanup的变量，他们的调用顺序是&lt;code&gt;先入后出&lt;/code&gt;的栈式顺序；&lt;br&gt;而且，cleanup是先于这个对象的&lt;code&gt;dealloc&lt;/code&gt;调用的。&lt;/p&gt;
&lt;h2 id=&quot;进阶用法&quot;&gt;&lt;a href=&quot;#进阶用法&quot; class=&quot;headerlink&quot; title=&quot;进阶用法&quot;&gt;&lt;/a&gt;进阶用法&lt;/h2&gt;&lt;p&gt;既然&lt;code&gt;__attribute__((cleanup(...)))&lt;/code&gt;可以用来修饰变量，&lt;code&gt;block&lt;/code&gt;当然也是其中之一，写一个block的cleanup函数非常有趣：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// void(^block)(void)的指针是void(^*block)(void)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; blockCleanUp(__&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^*block)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (*block)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;于是在一个作用域里声明一个block：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 加了个`unused`的attribute用来消除`unused variable`的warning&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^block)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) __attribute__((cleanup(blockCleanUp), unused)) = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;I&#39;m dying...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// 这里输出&quot;I&#39;m dying...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里不得不提万能的&lt;code&gt;Reactive Cocoa&lt;/code&gt;中神奇的&lt;code&gt;@onExit&lt;/code&gt;方法，其实正是上面的写法，简单定义个宏：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define onExit\&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^block)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) __attribute__((cleanup(blockCleanUp), unused)) = ^&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用这个宏就能将一段写在前面的代码最后执行：  &lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    onExit &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;yo&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// Log &quot;yo&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的写法可以将成对出现的代码写在一起，比如说一个lock：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRecursiveLock&lt;/span&gt; *aLock = [[&lt;span class=&quot;built_in&quot;&gt;NSRecursiveLock&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[aLock lock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//     有&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//        100多万行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[aLock unlock]; &lt;span class=&quot;comment&quot;&gt;// 看到这儿的时候早忘了和哪个lock对应着了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用了&lt;code&gt;onExit&lt;/code&gt;之后，代码更集中了：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRecursiveLock&lt;/span&gt; *aLock = [[&lt;span class=&quot;built_in&quot;&gt;NSRecursiveLock&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[aLock lock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;onExit &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [aLock unlock]; &lt;span class=&quot;comment&quot;&gt;// 妈妈再也不用担心我忘写后半段了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    爱多少行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//           就多少行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还是那句老话：剩下的就全靠想象力了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;编译器属性&lt;code&gt;__attribute__&lt;/code&gt;用于向编译器描述特殊的标识、检查或优化，几个常用的用法看&lt;a href=&quot;http://nshipster.com/__attribute__/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《
    
    </summary>
    
    
      <category term="objc的秘密" scheme="http://blog.sunnyxx.com/tags/objc%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iPhone6分辨率与适配</title>
    <link href="http://blog.sunnyxx.com/2014/09/10/iphone6-resolution/"/>
    <id>http://blog.sunnyxx.com/2014/09/10/iphone6-resolution/</id>
    <published>2014-09-10T11:43:05.000Z</published>
    <updated>2016-04-09T05:00:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;分辨率和像素&quot;&gt;&lt;a href=&quot;#分辨率和像素&quot; class=&quot;headerlink&quot; title=&quot;分辨率和像素&quot;&gt;&lt;/a&gt;分辨率和像素&lt;/h1&gt;&lt;p&gt;经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iPhone5分辨率320x568，像素640x1136，@2x&lt;/li&gt;
&lt;li&gt;iPhone6分辨率375x667，像素750x1334，@2x&lt;/li&gt;
&lt;li&gt;iPhone6 Plus分辨率414x736，像素1242x2208，@3x，（注意，在这个分辨率下渲染后，图像等比降低pixel分辨率至1080p(1080x1920)）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/51530583gw1ek7mqv36zxj20go099jrm.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;PaintCode做了&lt;a href=&quot;http://www.paintcodeapp.com/news/iphone-6-screens-demystified&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;几个图讲解的非常明了&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;自动适配&quot;&gt;&lt;a href=&quot;#自动适配&quot; class=&quot;headerlink&quot; title=&quot;自动适配&quot;&gt;&lt;/a&gt;自动适配&lt;/h1&gt;&lt;p&gt;不处理时自动等比拉伸，如果在老工程打印屏幕frame，依然是&lt;code&gt;320x568&lt;/code&gt;&lt;br&gt;对比自动适配的和完美适配的导航栏就能看出问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/51530583gw1ek7mze3ckrj219y060glw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为拉伸所以会有一些虚，导航栏明显比64要大，但相比3.5寸到4寸的留黑边还是好很多。&lt;br&gt;如何关闭自动适配方案呢？这个还是老思路，换启动图：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/51530583gw1ek7n9aqlnsj20oc08maa9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了换启动图外，不得不说的是，新Xcode中可以使用一个&lt;code&gt;xib&lt;/code&gt;来设置启动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/51530583gw1ek7nce5e1uj20pe07cgmj.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过这个xib不能关联任何的代码（不能自定义View的Class，不能IBOutlet，不能加Object），可以理解成这个xib就是一张截图，这个方案的好处在于可以使用到&lt;code&gt;Size Classes&lt;/code&gt;来针对不同屏幕布局这个xib（感兴趣可以看&lt;a href=&quot;http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/&quot;&gt;《Size Classes初探》&lt;/a&gt;）&lt;/p&gt;
&lt;h1 id=&quot;关于手动适配&quot;&gt;&lt;a href=&quot;#关于手动适配&quot; class=&quot;headerlink&quot; title=&quot;关于手动适配&quot;&gt;&lt;/a&gt;关于手动适配&lt;/h1&gt;&lt;p&gt;只要手动指定了启动图或者那个xib，屏幕分辨率就已经变成应有的大小了，老代码中所有关于写死frame值的代码通通倒霉，如果去手动适配就要全部适配，建议&lt;strong&gt;在找到个可行方案前先不要做修改&lt;/strong&gt;，自动适配方案还算不影响使用。  &lt;/p&gt;
&lt;p&gt;面对4个分辨率的iPhone，建议使用&lt;code&gt;Auto Layout&lt;/code&gt;布局 + &lt;code&gt;Image Assets&lt;/code&gt;管理各个分辨率的图片 + &lt;code&gt;Interface Builder&lt;/code&gt;（xib+storyboard）构建UI，&lt;code&gt;Size Classes&lt;/code&gt;在低版本iOS系统的表现未知。想要这套手动适配方案，起码你的工程需要部署在iOS6+，还不用AutoLayout布局的会死的蛮惨。&lt;/p&gt;
&lt;h1 id=&quot;关于Xcode6&quot;&gt;&lt;a href=&quot;#关于Xcode6&quot; class=&quot;headerlink&quot; title=&quot;关于Xcode6&quot;&gt;&lt;/a&gt;关于Xcode6&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模拟器路径被换成了 &lt;code&gt;~/Library/Developer/CoreSimulator/Devices/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;xcode6中已经找不到iOS6的模拟器了，是时候说服大家放弃iOS7-了&lt;/li&gt;
&lt;li&gt;&lt;del&gt;现在起提交App Store强制需要支持64位，是时候梳理一遍所有依赖的第三方lib，更新到64位&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;One more thing…按这名命的规律…&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iPhone6&lt;/code&gt; -&amp;gt; &lt;code&gt;iPhone6+&lt;/code&gt; -&amp;gt; &lt;code&gt;iPhone6++&lt;/code&gt;? -&amp;gt; &lt;code&gt;iPhone6#&lt;/code&gt;?&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分辨率和像素&quot;&gt;&lt;a href=&quot;#分辨率和像素&quot; class=&quot;headerlink&quot; title=&quot;分辨率和像素&quot;&gt;&lt;/a&gt;分辨率和像素&lt;/h1&gt;&lt;p&gt;经新xcode6模拟器验证（分辨率为pt，像素为真实pixel）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iPhone5
    
    </summary>
    
    
      <category term="iOS8" scheme="http://blog.sunnyxx.com/tags/iOS8/"/>
    
  </entry>
  
</feed>
