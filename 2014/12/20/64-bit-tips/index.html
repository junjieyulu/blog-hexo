<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 64-bit Tips · sunnyxx的技术博客</title><meta name="description" content="64-bit Tips - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">64-bit Tips</h1><div class="post-time">2014年12月20日</div><div class="post-content"><p>终究还是来了。Apple下发了支持64位的最后通牒：</p>
<blockquote>
<p>As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.</p>
</blockquote>
<p>早应该做的适配终于要开始动工了，苦了64位的CPU运行了这么久32位的程序。前段时间公司项目完成了64-bit包的适配，本没那么复杂的事被无数不标准的老代码搅和的不轻，总结几个Tip共勉。</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="拒绝基本数据类型和隐式转换"><a href="#拒绝基本数据类型和隐式转换" class="headerlink" title="拒绝基本数据类型和隐式转换"></a>拒绝基本数据类型和隐式转换</h2><p>首当其冲的就是基本类型，比如下面4个类型在32-bit和64-bit下分别是多长呢？  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t s1 = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">size_t s2 = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">size_t s3 = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">size_t s4 = <span class="keyword">sizeof</span>(<span class="keyword">double</span>);</span><br></pre></td></tr></table></figure>
<p>32-bit下：<code>4, 4, 4, 8</code>；64-bit下：<code>4, 8, 4, 8</code><br>（PS： 这个结果随编译器，换其他平台可不一定）<br>它们的长度变化可能并非我们对64-bit长度加倍的预期，所以说，程序中出现<code>sizeof</code>的代码多看两眼。而且，除非你明确知道自己在做什么，应该使用下面的类型代替基本类型：  </p>
<ul>
<li>int -&gt; NSInteger</li>
<li>unsigned -&gt; NSUInteger</li>
<li>float -&gt; CGFloat</li>
<li>动画时间 -&gt; NSTimeInterval</li>
<li>…</li>
</ul>
<p>这些都是SDK中定义的类型，而我们大部分时间都在跟SDK的API们打交道，使用它们能将类型转换的影响降低很多。</p>
<p>再比如说下面的代码：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; items.count; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是，for循环一次都没有进。<br>数组的<code>count</code>是<code>NSUInteger</code>类型的，-1与其比较时隐式转换成<code>NSUInteger</code>，变成了一个很大的数字：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p i</span><br><span class="line">(<span class="keyword">int</span>) $<span class="number">0</span> = <span class="number">-1</span></span><br><span class="line">(lldb) p (<span class="built_in">NSUInteger</span>)i</span><br><span class="line">(<span class="built_in">NSUInteger</span>) $<span class="number">1</span> = <span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure>
<p>这和64-bit到没啥关系，想要说明的是，这种隐式转换也需要小心，一定要注意和这个变量相关的所有操作（赋值、比较、转换）<br>老式for循环可以考虑写成：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; items.count; index++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当然，数组遍历还是更推荐用<code>for-in</code>或<code>block</code>版本的，它们之间的比较可以回顾下<a href="http://blog.sunnyxx.com/2014/04/30/ios_iterator/">这篇文章</a>。</p>
<h2 id="使用新版枚举"><a href="#使用新版枚举" class="headerlink" title="使用新版枚举"></a>使用新版枚举</h2><p>和上面的原因差不多，枚举应该使用新版的写法：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIViewAnimationCurve</span>) &#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationCurveEaseInOut</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationCurveEaseIn</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationCurveEaseOut</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationCurveLinear</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不仅能为枚举值指定类型，而且当赋值赋错类型时，编译器还会给出警告，没理由不用这种写法。</p>
<h2 id="替代Format字符串"><a href="#替代Format字符串" class="headerlink" title="替代Format字符串"></a>替代Format字符串</h2><p>适配64-bit时，你是否遇到了下面的恶心写法：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"数组元素个数：%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)items.count);</span><br></pre></td></tr></table></figure>
<p>一般情况下，利用<code>NSNumber</code>的<code>@</code>语法糖就可以解决：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"数组元素个数：%@"</span>, @(items.count));</span><br></pre></td></tr></table></figure>
<p>同理，int转string也可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> i = <span class="number">10086</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string = @(i).stringValue;</span><br></pre></td></tr></table></figure>
<p>当然，如需要<code>%.2f</code>这种Format就不适用了。</p>
<h2 id="64-bit下的BOOL"><a href="#64-bit下的BOOL" class="headerlink" title="64-bit下的BOOL"></a>64-bit下的BOOL</h2><p>32-bit下，BOOL被定义为<code>signed char</code>，@encode(BOOL)的结果是<code>&#39;c&#39;</code><br>64-bit下，BOOL被定义为<code>bool</code>，@encode(BOOL)结果是<code>&#39;B&#39;</code><br>更直观的解释是：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/t (<span class="keyword">signed</span> <span class="keyword">char</span>)<span class="number">7</span></span><br><span class="line">(<span class="built_in">BOOL</span>) $<span class="number">0</span> = <span class="number">0</span>b00000111 (<span class="literal">YES</span>)</span><br><span class="line">(lldb) p/t (<span class="keyword">bool</span>)<span class="number">7</span></span><br><span class="line">(<span class="keyword">bool</span>) $<span class="number">1</span> = <span class="number">0</span>b00000001 (<span class="literal">YES</span>)</span><br></pre></td></tr></table></figure>
<p>32-bit版本的BOOL包括了256个值的可能性，还会引起一些坑，像<a href="http://www.bignerdranch.com/blog/bools-sharp-corners/" target="_blank" rel="external">这篇文章</a>所说的。而64-bit下只有0（NO），1（YES）两种可能，终于给BOOL正了名。    </p>
<h2 id="不直接取isa指针"><a href="#不直接取isa指针" class="headerlink" title="不直接取isa指针"></a>不直接取isa指针</h2><p>编译器已经默认禁用了这种使用，isa指针在32位下是Class的地址，但在64位下利用bits mask才能取出来真正的地址，若真需要，使用runtime的<code>object_getClass</code> 和<code>object_setClass</code>方法。关于64位下isa的讲解可以看<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="external">这篇文章</a></p>
<h2 id="解决第三方lib依赖和lipo命令"><a href="#解决第三方lib依赖和lipo命令" class="headerlink" title="解决第三方lib依赖和lipo命令"></a>解决第三方lib依赖和lipo命令</h2><p>以源码形式出现在工程中的第三方lib，只要把target加上<code>arm64</code>编译就好了。<br>恶心的就是直接拖进工程的那些静态库(.a)或者framework，就需要重新找支持64-bit的包了。这时候就能看出哪些是已无人维护的lib了，是时候找个替代品了（比如我全网找不到工程中用到的一个音频库的64位包，终于在一个哥们的github上找到，哭着给了个star- -）  </p>
<h3 id="打印Mach-O文件支持的架构"><a href="#打印Mach-O文件支持的架构" class="headerlink" title="打印Mach-O文件支持的架构"></a>打印Mach-O文件支持的架构</h3><p>如何看一个可执行文件是不是支持64-bit呢？   </p>
<p>使用<code>lipo -info</code>命令，比如看看UIKit支持的架构：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前在Xcode Frameworks目录</span></span><br><span class="line">sunnyxx$ lipo -info <span class="built_in">UIKit</span>.framework/<span class="built_in">UIKit</span></span><br><span class="line">Architectures <span class="keyword">in</span> the fat file: <span class="built_in">UIKit</span>.framework/<span class="built_in">UIKit</span> are: arm64 armv7s</span><br></pre></td></tr></table></figure>
<p>想看的更详细的信息可以使用<code>lipo -detailed_info</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sunnyxx$ lipo -detailed_info <span class="built_in">UIKit</span>.framework/<span class="built_in">UIKit</span></span><br><span class="line">Fat header <span class="keyword">in</span>: <span class="built_in">UIKit</span>.framework/<span class="built_in">UIKit</span></span><br><span class="line">fat_magic <span class="number">0xcafebabe</span></span><br><span class="line">nfat_arch <span class="number">2</span></span><br><span class="line">architecture arm64</span><br><span class="line">    cputype CPU_TYPE_ARM64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class="line">    offset <span class="number">4096</span></span><br><span class="line">    size <span class="number">16822272</span></span><br><span class="line">    align <span class="number">2</span>^<span class="number">12</span> (<span class="number">4096</span>)</span><br><span class="line">architecture armv7s</span><br><span class="line">    cputype CPU_TYPE_ARM</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM_V7S</span><br><span class="line">    offset <span class="number">16826368</span></span><br><span class="line">    size <span class="number">14499840</span></span><br><span class="line">    align <span class="number">2</span>^<span class="number">12</span> (<span class="number">4096</span>)</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用<code>file</code>命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sunnyxx$ file UIKit.framework/UIKit</span><br><span class="line">UIKit.framework/UIKit: Mach-O universal binary with 2 architectures</span><br><span class="line">UIKit.framework/UIKit (for architecture arm64):Mach-O 64-bit dynamically linked shared library</span><br><span class="line">UIKit.framework/UIKit (for architecture armv7s):Mach-O dynamically linked shared library arm</span><br></pre></td></tr></table></figure>
<p>上述命令对<code>Mach-O</code>文件适用，静态库<code>.a</code>文件，framework中的<code>.a</code>文件，自己app的可执行文件都可以打印下看看。  </p>
<h3 id="合并多个架构的包"><a href="#合并多个架构的包" class="headerlink" title="合并多个架构的包"></a>合并多个架构的包</h3><p>如果，我们有<code>MyLib-32.a</code>和<code>MyLib-64.a</code>，可以使用<code>lipo -create</code>命令合并：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunnyxx$ lipo -create MyLib-32.a MyLib-64.a -output MyLib.a</span><br></pre></td></tr></table></figure>
<h2 id="支持64-bit后程序包会变大么？"><a href="#支持64-bit后程序包会变大么？" class="headerlink" title="支持64-bit后程序包会变大么？"></a>支持64-bit后程序包会变大么？</h2><p>会，支持64-bit后，多了一个<code>arm64</code>架构，理论上每个架构一套指令，但相比原来会大多少还不好说，我们这里增加了大概50%，还有听说会增加一倍的。</p>
<h2 id="一个lib包含了很多的架构，会打到最后的包里么？"><a href="#一个lib包含了很多的架构，会打到最后的包里么？" class="headerlink" title="一个lib包含了很多的架构，会打到最后的包里么？"></a>一个lib包含了很多的架构，会打到最后的包里么？</h2><p>不会，如果lib中有<code>armv7, armv7s, arm64, i386</code>架构，而target architecture选择了<code>armv7s, arm64</code>，那么只会从lib中link指定的这两个架构的二进制代码，其他架构下的代码不会link到最终可执行文件中；反过来，一个lib需要在模拟器环境中正常link，也得包含i386架构的指令。</p>
<h2 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h2><p>最后列一下官方文档中的注意点：  </p>
<ul>
<li>不要将指针强转成整数</li>
<li>程序各处使用统一的数据类型</li>
<li>对不同类型的整数做运算时一定要注意</li>
<li>需要定长变量时，使用如<code>int32_t, int64_t</code>这种定长类型</li>
<li>使用malloc时，不要写死size</li>
<li>使用能同时适配两个架构的格式化字符串</li>
<li>注意函数和函数指针（类型转换和可变参数）</li>
<li>不要直接访问Objective-C的指针（isa）</li>
<li>使用内建的同步原语（Primitives）</li>
<li>不要硬编码虚存页大小</li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1788/_index.html#//apple_ref/doc/uid/DTS40013354" target="_blank" rel="external">Go Position Independent</a></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013501-CH1-SW1</a><br><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="external">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a><br><a href="http://www.bignerdranch.com/blog/64-bit-smorgasbord/" target="_blank" rel="external">http://www.bignerdranch.com/blog/64-bit-smorgasbord/</a><br><a href="http://www.bignerdranch.com/blog/bools-sharp-corners/" target="_blank" rel="external">http://www.bignerdranch.com/blog/bools-sharp-corners/</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/01/17/self-in-arc/" class="prev">上一篇</a><a href="/2014/12/18/class-cluster/" class="next">下一篇</a></div><div data-thread-key="2014/12/20/64-bit-tips/" data-title="64-bit Tips" data-url="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>