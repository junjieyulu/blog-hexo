<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> xib的动态桥接 · sunnyxx的技术博客</title><meta name="description" content="xib的动态桥接 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">xib的动态桥接</h1><div class="post-time">2014年7月1日</div><div class="post-content"><h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p>个人很主张使用<code>Interface Builder</code>(以下都简称<code>IB</code>)来构建程序UI，包括<code>storyboard</code>和<code>xib</code>，相比代码更可视和易于修改，尤其在使用AutoLayout的时候，一目了然。<br>但用了这么久IB之后发现一个很大的槽点，就是IB间很难<code>嵌套混用</code>，比如一个xib中的view是另一个xib的子view，或者一个storyboard中两个vc都用到了一个xib构建的view等。解决方法一般是代码手动拼接，这就造成了比较混乱的情况。  </p>
<p><strong>本文将尝试解决这个问题，实现xib的<code>动态桥接</code>，并提供一个支持<code>cocoapods</code>的开源工具类供方便使用。</strong></p>
<h2 id="一张图顶十句话："><a href="#一张图顶十句话：" class="headerlink" title="一张图顶十句话："></a>一张图顶十句话：</h2><p><img src="http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg" width="500" align="middle">  </p>
<h2 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h2><p><img src="http://ww3.sinaimg.cn/large/51530583gw1ehzgoiqfkfj20hs0qo75u.jpg" width="300" align="middle"></p>
<hr>
<h1 id="黑魔法方法"><a href="#黑魔法方法" class="headerlink" title="黑魔法方法"></a>黑魔法方法</h1><p>实现这个功能的关键在于：在ib加载的某个时刻将<code>placeholder</code>的view动态替换成从xib加载的view，下面的方法就可以做到：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)awakeAfterUsingCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_REPLACES_RECEIVER</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法很少用到，在<code>NSObject (NSCoderMethods)</code>中定义，由<code>NSCoder</code>在decode过程中调用（于<code>-initWithCoder:</code>之后），所以说就算从文件里decode出来的对象也会走这个方法。<br>方法后面有<code>NS_REPLACES_RECEIVER</code>这个宏：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED</span></span><br></pre></td></tr></table></figure>
<p>在clang的文档中可以找到对这个<a href="http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self" target="_blank" rel="external">编译器属性的介绍</a>  </p>
<blockquote>
<p>One use of this attribute is declare your own init-like methods that do not follow the standard Cocoa naming conventions.</p>
</blockquote>
<p>所以这个宏主要为了给编译器标识出这个方法可以像<code>self = [super init]</code>一样使用，并作出合理的内存管理。<br>So，这个方法提供了一个机会，<strong>可以将decode出来的对象替换成另一个对象</strong></p>
<p><strong>动态桥接流程</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)awakeAfterUsingCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0. 判断是否要进行替换</span></span><br><span class="line">    <span class="comment">// 1. 根据self.class从xib创建真正的view</span></span><br><span class="line">    <span class="comment">// 2. 将placeholder的属性、autolayout等替换到真正的view上</span></span><br><span class="line">    <span class="comment">// 3. return 真正的view</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程不难理解，就是有2个小难点：</p>
<ul>
<li>步骤1从xib创建真正的view时也会调用这个方法，会造成<code>递归</code>，如何判断</li>
<li>迁移<code>AutoLayoutConstrains</code></li>
</ul>
<h3 id="解决递归问题"><a href="#解决递归问题" class="headerlink" title="解决递归问题"></a>解决递归问题</h3><p>这个topic全网可能就<a href="http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading" target="_blank" rel="external">《这篇文章》</a>有写，本文也是从它发起的，但是发现它的方法并不能解决所有问题（尤其是用storyboard加载xib时），所以换了个思路，采取了设置标志位的方式避免递归调用：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)awakeAfterUsingCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> awakeAfterUsingCoder:aDecoder];</span><br><span class="line">    <span class="keyword">if</span> (这个类的Loading标志位 -&gt; <span class="literal">NO</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Loading标志位 -&gt; <span class="literal">YES</span></span><br><span class="line">        从xib加载真实的View (这里会递归调用这个函数)</span><br><span class="line">        <span class="keyword">return</span> 真实View</span><br><span class="line">    &#125;</span><br><span class="line">    Loading标志位 -&gt; <span class="literal">NO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法有点土，但是有效了，源代码文章后面会给地址。</p>
<h3 id="迁移AutoLayoutConstrains"><a href="#迁移AutoLayoutConstrains" class="headerlink" title="迁移AutoLayoutConstrains"></a>迁移AutoLayoutConstrains</h3><p>由于IB在加载AutoLayoutConstrains时的顺序是<strong>先加载子View内部的约束，后加载父View上的约束</strong>，而我们替换placeholder的时机是：</p>
<ol>
<li>placehodler view被创建（只带width，height的自身约束）</li>
<li>真正的view被从xib动态加载（带其子view的所有约束）</li>
<li><strong><em>placeholder被替换成真的view</em></strong></li>
<li>placeholder view在其父View（一直到父父父…View）的约束被创建</li>
</ol>
<p>所以说，迁移AutoLayout时，<code>只需要把placeholder view的自身约束copy到真实View上就好了</code>（停顿10s感受下）<br>代码如下：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)replaceAutolayoutConstrainsFromView:(<span class="built_in">UIView</span> *)placeholderView toView:(<span class="built_in">UIView</span> *)realView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSLayoutConstraint</span> *constraint <span class="keyword">in</span> placeholderView.constraints) &#123;</span><br><span class="line">        <span class="built_in">NSLayoutConstraint</span>* newConstraint  = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:realView</span><br><span class="line">                                                     attribute:constraint.firstAttribute</span><br><span class="line">                                                     relatedBy:constraint.relation</span><br><span class="line">                                                        toItem:<span class="literal">nil</span> <span class="comment">// Only first item</span></span><br><span class="line">                                                     attribute:constraint.secondAttribute</span><br><span class="line">                                                    multiplier:constraint.multiplier</span><br><span class="line">                                                      constant:constraint.constant];</span><br><span class="line">        newConstraint.shouldBeArchived = constraint.shouldBeArchived;</span><br><span class="line">        newConstraint.priority = constraint.priority;</span><br><span class="line">        [realView addConstraint:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One more thing，保证AutoLayout生效还要加上下面这句话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="开源项目XXNibBridge"><a href="#开源项目XXNibBridge" class="headerlink" title="开源项目XXNibBridge"></a>开源项目XXNibBridge</h1><p>光说方案不给源码还是不地道的，demo放到了<a href="https://github.com/sunnyxx/XXNibBridge" target="_blank" rel="external">我的github上面的XXNibBridge项目</a>，回顾一下上面的关系图：</p>
<p><img src="http://ww2.sinaimg.cn/large/51530583gw1ehzgklik42j20m80go0ua.jpg" width="400">  </p>
<p>不得不提到<code>IB命名约定</code>的最佳实践方案：</p>
<p><strong>将类名作为Cell或者VC的Reusable Identifier</strong><br>设<code>ReuseIdentifier</code>一直比较蛋疼，我一般将Cell的<code>类名</code>作为<code>ReuseIdentifier</code>（当然，大多数情况我们都会子类化Cell的），写法如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.tableView registerClass:[XXSarkCell class] forCellReuseIdentifier:<span class="built_in">NSStringFromClass</span>([XXSarkCell class])];</span><br></pre></td></tr></table></figure>
<p>在<code>dequeueCell</code>的时候同理，这样的好处在于省去了起名的恶心、通过ReuseId可以直接找到Cell类、同时重构Cell类名时ReuseId也不用去再改。</p>
<p><strong>View的xib与View的类名同名</strong> 同理   </p>
<p>实现了桥接Xib的功能的同时，也简单实现了这个命名约定：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXNibBridge.h</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)xx_nibID; <span class="comment">// 类名</span></span><br><span class="line">+ (<span class="built_in">UINib</span> *)xx_nib; <span class="comment">// 返回类名对应nib</span></span><br><span class="line">+ (<span class="keyword">id</span>)xx_loadFromNib; <span class="comment">// 对应nib的类对象</span></span><br><span class="line">+ (<span class="keyword">id</span><span class="comment">/*UIViewController*/</span>)xx_loadFromStoryboardNamed:(<span class="built_in">NSString</span> *)name; <span class="comment">// 返回类名对应的vc</span></span><br></pre></td></tr></table></figure>
<p>所以之后的代码可以这么写:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tableView registerNib:[XXSarkView xx_nib] forCellReuseIdentifier:[XXSarkView xx_nibID]];</span><br></pre></td></tr></table></figure>
<h1 id="XXNibBridge的使用"><a href="#XXNibBridge的使用" class="headerlink" title="XXNibBridge的使用"></a>XXNibBridge的使用</h1><p><strong>Cocoapods安装</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod 'XXNibBridge', :git =&gt; 'https://github.com/sunnyxx/XXNibBridge.git'</span><br></pre></td></tr></table></figure>
<p>对于要支持Bridge的类，重载下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"XXNibBridge.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXDogeView</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)xx_shouldApplyNibBridging</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在父的Xib或Storyboard中拖个UIView进来作为Placeholder，设置为真实Nib的类</p>
<p><img src="http://ww1.sinaimg.cn/large/51530583gw1ei03b0vuzmj20z40a6q4e.jpg" width="500">  </p>
<p>保证真实Nib的类名和Nib名相同，记得在Nib中设好Class<br><img src="http://ww3.sinaimg.cn/large/51530583gw1ei03dn8rq8j206g036q2z.jpg" width="200"></p>
<p><strong>Done.</strong><br><img src="http://ww4.sinaimg.cn/large/51530583gw1ei03g01mmej20ga07sjrt.jpg" width="400"></p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading" target="_blank" rel="external">http://blog.yangmeyer.de/blog/2012/07/09/an-update-on-nested-nib-loading</a><br><a href="http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints" target="_blank" rel="external">http://stackoverflow.com/questions/19816703/replacing-nsview-while-keeping-autolayout-constraints</a><br><a href="http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self" target="_blank" rel="external">http://clang-analyzer.llvm.org/annotations.html#attr_ns_consumes_self</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/07/17/ios_0code_vc/" class="prev">上一篇</a><a href="/2014/04/30/ios_iterator/" class="next">下一篇</a></div><div data-thread-key="2014/07/01/ios_ib_bridge/" data-title="xib的动态桥接" data-url="http://blog.sunnyxx.com/2014/07/01/ios_ib_bridge/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>