<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> objc与鸭子对象（上） · sunnyxx的技术博客</title><meta name="description" content="objc与鸭子对象（上） - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">objc与鸭子对象（上）</h1><div class="post-time">2014年8月24日</div><div class="post-content"><p>这是《objc与鸭子对象》的上半部分，<a href="http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/">《objc与鸭子对象（下）》</a>中介绍了鸭子类型的进阶用法、依赖注入以及demo。</p>
<h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p><img src="http://ww1.sinaimg.cn/mw690/51530583jw1ejqkwtxr1dj20rs0ijgo7.jpg" width="300"><br><code>鸭子类型</code>(Duck Type)即：<strong>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”</strong>，换成程序猿语言就是：<strong>“当调用者知道这个对象能调用什么方法时，管它这个对象到底是什么类的实例呢”</strong>。本文对objc中的鸭子类型对象进行简单探究，并用一个“只用一个类实现Json Entity”的小demo实践下这个思路的魔力。进阶篇请看下半部分。</p>
<hr>
<h1 id="objc与鸭子类型"><a href="#objc与鸭子类型" class="headerlink" title="objc与鸭子类型"></a>objc与鸭子类型</h1><h2 id="id类型是个大鸭子"><a href="#id类型是个大鸭子" class="headerlink" title="id类型是个大鸭子"></a>id类型是个大鸭子</h2><p>鸭子类型是动态语言的特性，编译时并不决定函数调用关系，说白了所有的类型声明都是给编译器看的。objc在动态和静态方面找到了不错的平衡，既保留了严格的静态检查也没破坏运行时的动态特性。<br>我们知道，向一个objc对象（或Class）发消息，实际上就是沿着它的<code>isa</code>指针寻找真正函数地址，所以只要一个对象满足下面的结构，就可以对它发送消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>也就是熟知的<code>id</code>类型，objc在语言层面先天就支持了这个基本的鸭子类型，我们可以将任意一个对象强转为id类型从而向它发送消息，就算它并不能响应这个消息，编译器也无从知晓。<br>正如<a href="http://www.informit.com/articles/article.aspx?p=1353396" target="_blank" rel="external">这篇文章</a>中对objc对象的简短定义：<code>The best definition for a Smalltalk or Objective-C &quot;object&quot; is &quot;something that can respond to messages.</code> object并非一定是某个特定类型的实例，只要它能响应需要的消息就可以了。</p>
<h2 id="从-interface到-protocol"><a href="#从-interface到-protocol" class="headerlink" title="从@interface到@protocol"></a>从@interface到@protocol</h2><p>正如objc先天支持的动态的<code>id</code>类型，<code>@protocol</code>为鸭子类型提供了编译时的强类型检查，实现了Cocoa中经典的鸭子类型使用场景：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UITableViewDataSource</span>&gt; dataSource;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UITableViewDelegate</span>&gt;   delegate;</span><br></pre></td></tr></table></figure>
<p>利用鸭子类型设计的接口会给使用者更大的灵活度。同时<code>@protocol</code>可以用来建立<code>伪继承</code>关系  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIScrollViewDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDelegate</span>&lt;<span class="title">NSObject</span>, <span class="title">UIScrollViewDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;NSObject&gt;</code>协议的存在一方面是给<code>NSProxy</code>这样的其他根类使用，同时也给了鸭子协议类型一个根类型，正如给了大部分类一个NSObject根类一样。说个小插曲，由于objc中Class也是<code>id</code>类型，形如<code>id&lt;UITableViewDataSource&gt;</code>的鸭子类型是可以用Class对象来扮演的，只需要把实例方法替换成类方法，如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DataSource</span></span></span><br><span class="line">+ (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>设置table view的data source：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.dataSource = (Class&lt;<span class="built_in">UITableViewDataSource</span>&gt;)[DataSource class];</span><br></pre></td></tr></table></figure>
<p>这种非主流写法合法且运行正常，归功于objc中加号和减号方法在<code>@selector</code>中并未体现，在<code>@protocol</code>中也是形同虚设，这种代码我相信没人真的写，但确实能体现鸭子类型的灵活性。</p>
<hr>
<h1 id="Demo-一个类实现Json-Entity"><a href="#Demo-一个类实现Json-Entity" class="headerlink" title="[Demo]一个类实现Json Entity"></a>[Demo]一个类实现Json Entity</h1><p><code>Entity</code>对象表示某个<strong>纯数据</strong>的结构，如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXUserEntity</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *sex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="comment">// balabala....</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实际开发中这种类往往对应着server端返回的一个JSON串，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;sunnyxx&quot;, &quot;sex&quot;: &quot;boy&quot;, &quot;age&quot;: 24, ...&#125;</span><br></pre></td></tr></table></figure>
<p>解析这些映射是个纯重复工作，建类、写属性、解析…如今已经有<a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="external">JSONModel</a>，<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a>等不错的框架帮忙。这个demo我们要用鸭子类型的思想去重新设计，把这些Entity类简化成一个鸭子类。</p>
<p>由于上面的<code>UserEntity</code>类，只有属性的getter和setter，这正对应了<code>NSMutableDictionary</code>的<code>objectForKey:</code>和<code>setObjectForKey:</code>，同时，JSON数据也会解析成字典，这就完成了巧妙的对接，下面去实现这个类。</p>
<p>真正干活的是一个字典，保证封装性和纯粹性，这个类直接使用<code>NSProxy</code>作为纯代理类，只暴露一个初始化方法就好了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDuckEntity.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXDuckEntity</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (instancetype)initWithJSO<span class="built_in">NString</span>:(<span class="built_in">NSString</span> *)json;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// XXDuckEntity.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXDuckEntity</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *innerDictionary;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>NSProxy</code>默认是没有初始化方法的，也省去了去规避其他初始化方法的麻烦，为了简单直接初始化时就把json串解开成字典（暂不考虑json是个array）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithJSO<span class="built_in">NString</span>:(<span class="built_in">NSString</span> *)json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [json dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">id</span> jsonObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.innerDictionary = [jsonObject mutableCopy];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSProxy</code>可以说除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好。往这个proxy发消息是注定会走消息转发的，首先判断下是不是一个getter或setter的selector：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    SEL changedSelector = aSelector;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> propertyNameScanFromGetterSelector:aSelector]) &#123;</span><br><span class="line">        changedSelector = <span class="keyword">@selector</span>(objectForKey:);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> propertyNameScanFromSetterSelector:aSelector]) &#123;</span><br><span class="line">        changedSelector = <span class="keyword">@selector</span>(setObject:forKey:);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span>.innerDictionary class] instanceMethodSignatureForSelector:changedSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>签名替换成字典的两个方法后开始走转发，在这里设置参数和对内部字典的真正调用：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *propertyName = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Try getter</span></span><br><span class="line">    propertyName = [<span class="keyword">self</span> propertyNameScanFromGetterSelector:invocation.selector];</span><br><span class="line">    <span class="keyword">if</span> (propertyName) &#123;</span><br><span class="line">        invocation.selector = <span class="keyword">@selector</span>(objectForKey:);</span><br><span class="line">        [invocation setArgument:&amp;propertyName atIndex:<span class="number">2</span>]; <span class="comment">// self, _cmd, key</span></span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.innerDictionary];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try setter</span></span><br><span class="line">    propertyName = [<span class="keyword">self</span> propertyNameScanFromSetterSelector:invocation.selector];</span><br><span class="line">    <span class="keyword">if</span> (propertyName) &#123;</span><br><span class="line">        invocation.selector = <span class="keyword">@selector</span>(setObject:forKey:);</span><br><span class="line">        [invocation setArgument:&amp;propertyName atIndex:<span class="number">3</span>]; <span class="comment">// self, _cmd, obj, key</span></span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.innerDictionary];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> forwardInvocation:invocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然还有这两个必不可少的从getter和setter中获取属性名的Helper：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)propertyNameScanFromGetterSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="built_in">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class="string">@":"</span>] count] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameterCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectorName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)propertyNameScanFromSetterSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="built_in">NSUInteger</span> parameterCount = [[selectorName componentsSeparatedByString:<span class="string">@":"</span>] count] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ([selectorName hasPrefix:<span class="string">@"set"</span>] &amp;&amp; parameterCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> firstColonLocation = [selectorName rangeOfString:<span class="string">@":"</span>].location;</span><br><span class="line">        <span class="keyword">return</span> [selectorName substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">3</span>, firstColonLocation - <span class="number">3</span>)].lowercaseString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的鸭子Entity就完成了，之后所有的Entity都可以使用<code>@protocol</code>而非子类化的方式来定义，如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">XXUserEntity</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *sex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">XXStudentEntity</span> &lt;<span class="title">XXUserEntity</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *school;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *teacher;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当数据从网络层回来时，鸭子类型让这个对象用起来和真有这么个类没什么两样：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestFinished:(XXDuckEntity&lt;XXStudentEntity&gt; *)student &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name: %@, school:%@"</span>, student.name, student.school);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，所有的entity被表示成了N个<code>&lt;Protocol&gt;</code>的<code>.h</code>文件加一个<code>XXDuckEntity</code>类，剩下的就靠想象力了。<br>这个demo的源码将在<a href="http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/">下半部分</a>之后给出</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="external">http://en.wikipedia.org/wiki/Duck_typing</a><br><a href="http://www.informit.com/articles/article.aspx?p=1353396" target="_blank" rel="external">http://www.informit.com/articles/article.aspx?p=1353396</a><br><a href="https://github.com/facebook/facebook-ios-sdk" target="_blank" rel="external">https://github.com/facebook/facebook-ios-sdk</a>  </p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/08/26/objc-duck-advanced/" class="prev">上一篇</a><a href="/2014/08/02/objc-weird-code/" class="next">下一篇</a></div><div data-thread-key="2014/08/24/objc-duck/" data-title="objc与鸭子对象（上）" data-url="http://blog.sunnyxx.com/2014/08/24/objc-duck/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>