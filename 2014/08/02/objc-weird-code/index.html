<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> objc非主流代码技巧 · sunnyxx的技术博客</title><meta name="description" content="objc非主流代码技巧 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">objc非主流代码技巧</h1><div class="post-time">2014年8月2日</div><div class="post-content"><h2 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h2><p>看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，总结下objc写码中遇到的各类<code>非主流</code>代码技巧和一些妙用：</p>
<ul>
<li>[娱乐向]objc最短的方法声明</li>
<li>[C]结构体的初始化</li>
<li>[C]三元条件表达式的两元使用</li>
<li>[C]数组的下标初始化</li>
<li>[objc]可变参数类型的block</li>
<li>[objc]readonly属性支持扩展的写法</li>
<li>[C]小括号内联复合表达式</li>
<li>[娱乐向]奇葩的C函数写法</li>
<li>[Macro]预处理时计算可变参数个数</li>
<li>[Macro]预处理断言</li>
<li>[多重]带自动提示的keypath宏</li>
</ul>
<hr>
<h2 id="娱乐向-objc最短的方法声明"><a href="#娱乐向-objc最短的方法声明" class="headerlink" title="[娱乐向]objc最短的方法声明"></a>[娱乐向]objc最短的方法声明</h2><p>先来个娱乐向的。<br>方法声明时有一下几个trick：  </p>
<p>返回值的<code>- (TYPE)</code>如果不写括号，编译器默认认为是<code>- (id)</code>类型:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- init;</span><br><span class="line">- (<span class="keyword">id</span>)init; <span class="comment">// 等价于</span></span><br></pre></td></tr></table></figure>
<p>同理，参数如果不写类型默认也是<code>id</code>类型:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo:arg;</span><br><span class="line">- (<span class="keyword">void</span>)foo:(<span class="keyword">id</span>)arg; <span class="comment">// 等价于</span></span><br></pre></td></tr></table></figure>
<p>还有，有多参数时<code>方法名</code>和<code>参数提示语</code>可以为空</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>):(<span class="keyword">id</span>)arg1 :(<span class="keyword">id</span>)arg2;</span><br><span class="line">- (<span class="keyword">void</span>)foo:(<span class="keyword">id</span>)arg1 bar:(<span class="keyword">id</span>)arg2; <span class="comment">// 省略前</span></span><br></pre></td></tr></table></figure>
<p>综上，最短的函数可以写成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- _;   <span class="comment">// 没错，这是一个oc方法声明</span></span><br><span class="line">- :_;  <span class="comment">// 这是一个带一个参数的oc方法声明</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">- (<span class="keyword">id</span>)_;</span><br><span class="line">- (<span class="keyword">id</span>) :(<span class="keyword">id</span>)_;</span><br></pre></td></tr></table></figure>
<p><em>PS: 方法名都没的方法只能靠<code>performSelector</code>来调用了，<code>selector</code>是<code>&quot;:&quot;</code>  </em></p>
<hr>
<h2 id="C-结构体的初始化"><a href="#C-结构体的初始化" class="headerlink" title="[C]结构体的初始化"></a>[C]结构体的初始化</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加(CGRect)强转也不会warning</span></span><br><span class="line"><span class="built_in">CGRect</span> rect1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">CGRect</span> rect2 = &#123;.origin.x=<span class="number">5</span>, .size=&#123;<span class="number">10</span>, <span class="number">10</span>&#125;&#125;; <span class="comment">// &#123;5, 0, 10, 10&#125;</span></span><br><span class="line"><span class="built_in">CGRect</span> rect3 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// &#123;1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="C-三元条件表达式的两元使用"><a href="#C-三元条件表达式的两元使用" class="headerlink" title="[C]三元条件表达式的两元使用"></a>[C]三元条件表达式的两元使用</h2><p>三元条件表达式<code>?:</code>是C中唯一一个三目运算符，用来替代简单的<code>if-else</code>语句，同时也是可以<strong>两元</strong>使用的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = inputString ?: <span class="string">@"default"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string = inputString ? inputString : <span class="string">@"default"</span>; <span class="comment">// 等价</span></span><br></pre></td></tr></table></figure>
<p>利用这个特性，我们还脑洞出了一个一行代码的 block 调用，平时我们的 block 是这样调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block0) &#123;</span><br><span class="line">  block0();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (block1) &#123;</span><br><span class="line">  <span class="keyword">int</span> result = block1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>居然可以简化成下面的样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!block0 ?: block0();</span><br><span class="line"><span class="keyword">int</span> result = !block1 ?: block1(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="C-数组的下标初始化"><a href="#C-数组的下标初始化" class="headerlink" title="[C]数组的下标初始化"></a>[C]数组的下标初始化</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> numbers[] = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">3</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">12306</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &#123;0, 3, 2, 1, 0, 12306&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个特性可以用来做<code>枚举值和字符串的映射</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, XXType)&#123;</span><br><span class="line">    XXType1,</span><br><span class="line">    XXType2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *XXTypeNameMapping[] = &#123;</span><br><span class="line">    [XXType1] = <span class="string">@"Type1"</span>,</span><br><span class="line">    [XXType2] = <span class="string">@"Type2"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="objc-可变参数类型的block"><a href="#objc-可变参数类型的block" class="headerlink" title="[objc]可变参数类型的block"></a>[objc]可变参数类型的block</h2><p>一个block像下面一样声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block1)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">void</span>(^block2)(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">void</span>(^block3)(<span class="built_in">NSNumber</span> *a, <span class="built_in">NSString</span> *b);</span><br></pre></td></tr></table></figure>
<p><strong>如果block的参数列表为空的话，相当于可变参数（不是void）</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)(); <span class="comment">// 返回值为void，参数可变的block</span></span><br><span class="line">block = block1; <span class="comment">// 正常</span></span><br><span class="line">block = block2; <span class="comment">// 正常</span></span><br><span class="line">block = block3; <span class="comment">// 正常</span></span><br><span class="line">block(@<span class="number">1</span>, <span class="string">@"string"</span>);  <span class="comment">// 对应上面的block3</span></span><br><span class="line">block(@<span class="number">1</span>); <span class="comment">// block3的第一个参数为@1，第二个为nil</span></span><br></pre></td></tr></table></figure>
<p>这样，block的主调和回调之间可以通过<code>约定</code>来决定block回传回来的参数是什么，有几个。如一个对网络层的调用：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestDataWithApi:(<span class="built_in">NSInteger</span>)api block:(<span class="keyword">void</span>(^)())block &#123;</span><br><span class="line">    <span class="keyword">if</span> (api == <span class="number">0</span>) &#123;</span><br><span class="line">        block(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (api == <span class="number">1</span>) &#123;</span><br><span class="line">        block(<span class="string">@"1"</span>, @<span class="number">2</span>, @[<span class="string">@"3"</span>, <span class="string">@"4"</span>, <span class="string">@"5"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主调者知道自己请求的是哪个Api，那么根据<code>约定</code>，他就知道block里面应该接受哪几个参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[server requestDataWithApi:<span class="number">0</span> block:^(<span class="built_in">NSInteger</span> a, <span class="built_in">NSInteger</span> b)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;];</span><br><span class="line">[server requestDataWithApi:<span class="number">1</span> block:^(<span class="built_in">NSString</span> *s, <span class="built_in">NSNumber</span> *n, <span class="built_in">NSArray</span> *a)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个特性在<code>Reactive Cocoa</code>的<code>-combineLatest:reduce:</code>等类似方法中已经使用的相当好了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)signals reduce:(<span class="keyword">id</span> (^)())reduceBlock;</span><br></pre></td></tr></table></figure>
<h2 id="objc-readonly属性支持扩展的写法"><a href="#objc-readonly属性支持扩展的写法" class="headerlink" title="[objc]readonly属性支持扩展的写法"></a>[objc]readonly属性支持扩展的写法</h2><p>假如一个类有一个<code>readonly</code>属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *friends;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>.m</code>中可以使用<code>_friends</code>来使用自动合成的这个变量，但假如：</p>
<ul>
<li>习惯使用<code>self.</code>来set实例变量时（只合成了getter）</li>
<li>希望重写getter进行懒加载时（重写getter时则不会生成下划线的变量，除非手动<code>@synthesize</code>）</li>
<li>允许子类重载这个属性来修改它时（编译报错属性修饰符不匹配）</li>
</ul>
<p>这种<code>readonly</code>声明方法就行不通了，所以下面的写法更有通用性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span><span class="comment">/*加上setter属性修饰符*/</span>) <span class="built_in">NSArray</span> *friends;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如想在<code>.m</code>中像正常属性一样使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *friends;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>子类化时同理。iOS SDK中很多地方都用到了这个特性。  </p>
<hr>
<h2 id="C-小括号内联复合表达式"><a href="#C-小括号内联复合表达式" class="headerlink" title="[C]小括号内联复合表达式"></a>[C]小括号内联复合表达式</h2><p><code>A compound statement enclosed in parentheses</code>原谅我的渣翻译- -，来自<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" target="_blank" rel="external">《gcc官方对此的说明》</a>，源自gcc对c的扩展，如今被clang继承。  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RETURN_VALUE_RECEIVER = &#123;(</span><br><span class="line">    <span class="comment">// Do whatever you want</span></span><br><span class="line">    RETURN_VALUE; <span class="comment">// 返回值</span></span><br><span class="line">)&#125;;</span><br></pre></td></tr></table></figure>
<p>于是乎可以发挥想象力了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.backgroundView = (&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    view.alpha = <span class="number">0.8</span>f;</span><br><span class="line">    view;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有点像block和内联函数的结合体，它最大的意义在于将代码<code>整理分块</code>，将同一个逻辑层级的代码包在一起；同时对于一个无需复用小段逻辑，也免去了重量级的调用函数，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.result = (&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M_2_PI; i+= M_PI_4) &#123;</span><br><span class="line">        result += sin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样使得代码量增大时层次仍然能比较明确。  </p>
<p><em>PS: 返回值和代码块结束点必须在结尾</em></p>
<h2 id="娱乐向-奇葩的C函数写法"><a href="#娱乐向-奇葩的C函数写法" class="headerlink" title="[娱乐向]奇葩的C函数写法"></a>[娱乐向]奇葩的C函数写法</h2><p>正常编译执行：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(a,b)</span></span><br><span class="line"><span class="keyword">int</span> a</span>; <span class="keyword">int</span> b;</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Macro-预处理时计算可变参数个数"><a href="#Macro-预处理时计算可变参数个数" class="headerlink" title="[Macro]预处理时计算可变参数个数"></a>[Macro]预处理时计算可变参数个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, RESULT, ...) RESULT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 5, 4, 3, 2, 1)</span></span><br><span class="line"><span class="keyword">int</span> count = COUNT_PARMS(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 预处理时count==3</span></span><br></pre></td></tr></table></figure>
<h2 id="Macro-预处理断言"><a href="#Macro-预处理断言" class="headerlink" title="[Macro]预处理断言"></a>[Macro]预处理断言</h2><p>下面的断言在编译前就生效  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_ASSERT(test) \</span><br><span class="line">    switch(0) &#123;\</span><br><span class="line">          case 0:\</span><br><span class="line">          case test:;\</span><br><span class="line">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>如断言上面预处理时计算可变参数个数：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C_ASSERT(COUNT_PARMS(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>如果断言失败，相当于<code>switch-case</code>中出现了两个<code>case:0</code>，则编译报错。  </p>
<h2 id="多重-带自动提示的keypath宏"><a href="#多重-带自动提示的keypath宏" class="headerlink" title="[多重]带自动提示的keypath宏"></a>[多重]带自动提示的keypath宏</h2><p>源自<code>Reactive Cocoa</code>中的宏：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> keypath2(OBJ, PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span></span><br></pre></td></tr></table></figure>
<p>原来写过一篇<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/">《介绍RAC宏的文章》</a>中曾经写过。这个宏在写PATH参数的同时是带自动提示的：<br><img src="http://images.cnitblog.com/blog/401798/201402/112147518936541.png" alt=""></p>
<h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><p>逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = ((void)(<span class="number">1</span>+<span class="number">2</span>), <span class="number">2</span>); <span class="comment">// a == 2</span></span><br></pre></td></tr></table></figure>
<p>于是上面的keypath宏的输出结果是<code>#PATH</code>也就是一个c字符串</p>
<h3 id="逻辑最短路径"><a href="#逻辑最短路径" class="headerlink" title="逻辑最短路径"></a>逻辑最短路径</h3><p>之前的文章没有弄清上面宏中<code>NO&amp;&amp;NO</code>的含义，其实这用到了编译器优化的特性：  </p>
<pre><code>if (NO &amp;&amp; [self shouldDo]/*不执行*/) {
    // 不执行
}
</code></pre><p>编译器知道在NO后且什么的结果都是NO，于是后面的语句被优化掉了。也就是说keypath宏中这个<code>NO &amp;&amp; ((void)OBJ.PATH, NO)</code>就使得在编译后后面的部分不出现在最后的代码中，于是乎既实现了keypath的自动提示功能，又保证编译后不执行多余的代码。  </p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/08/24/objc-duck/" class="prev">上一篇</a><a href="/2014/07/17/ios_0code_vc/" class="next">下一篇</a></div><div data-thread-key="2014/08/02/objc-weird-code/" data-title="objc非主流代码技巧" data-url="http://blog.sunnyxx.com/2014/08/02/objc-weird-code/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>