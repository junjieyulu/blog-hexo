<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> objc与鸭子对象（下） · sunnyxx的技术博客</title><meta name="description" content="objc与鸭子对象（下） - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">objc与鸭子对象（下）</h1><div class="post-time">2014年8月26日</div><div class="post-content"><h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p>这是《objc与鸭子对象》的下半部分，<a href="http://blog.sunnyxx.com/2014/08/24/objc-duck/">《objc与鸭子对象（上）》</a>中介绍了鸭子类型和它在objc中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的<code>依赖注入</code>，实现一个demo。</p>
<hr>
<h1 id="被误解了的面向对象"><a href="#被误解了的面向对象" class="headerlink" title="被误解了的面向对象"></a>被误解了的面向对象</h1><p>Smalltalk之父或者说面向对象之父（之一）的<strong>Alan Kay</strong>曾写过：</p>
<blockquote>
<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” - that is what the kernal of Smalltalk/Squeak is all about.</p>
</blockquote>
<p>面向对象的思想的核心并不在于<code>object</code>或者<code>class</code>，而在于<code>message</code>，或者说<strong>对象和类只是消息的载体</strong>。面向对象思想将程序按功能和逻辑分成了若干个类，每个类包含自己的代码、功能实现并提供对外接口，以黑箱模式运行，使得外部无需了解内部而协同使用，分解了复杂度并控制在一个个较小规模中，以消息作为其间所有的协作方式。<br>回到主题，理解了message才是全部，鸭子对象又可以更近一层，试想下整个程序，每个类除了知道自己的类之外其他类名一无所知，全部通过协议发消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)schoolWillStart:(<span class="keyword">id</span>&lt;School&gt;)school</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;Teacher&gt; teacher = school.teacher;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;Student&gt; student <span class="keyword">in</span> scholl.allStudents) &#123;</span><br><span class="line">        [student handIn:student.homework to:teacher];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Json-Entity的重构"><a href="#Json-Entity的重构" class="headerlink" title="Json Entity的重构"></a>Json Entity的重构</h1><p>回想上一篇中的JSON Entity类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDuckEntity.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXDuckEntity</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (instancetype)initWithJSO<span class="built_in">NString</span>:(<span class="built_in">NSString</span> *)json;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>干嘛caller要知道有这么个<code>Class</code>存在呢？它关心的只是能用哪些message通信而已。于是把类声明移动到<code>.m</code>中，简化成一个C的创建方法（类工厂方法同样会暴露类名）：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDuckEntity.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">id</span> XXDuckEntityCreateWithJSON(<span class="built_in">NSString</span> *json);</span><br><span class="line"><span class="comment">// XXDuckEntity.m</span></span><br><span class="line"><span class="keyword">id</span> XXDuckEntityCreateWithJSON(<span class="built_in">NSString</span> *json)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[XXDuckEntity alloc] initWithJSO<span class="built_in">NString</span>:json];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个类需要提供其他message接口供caller使用，则：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">XXDuckEntity</span> &lt;<span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *jsonString;</span><br><span class="line">- (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">id</span><span class="comment">/*&lt;XXDuckEntity&gt;*/</span> XXDuckEntityCreateWithJSON(<span class="built_in">NSString</span> *json);</span><br></pre></td></tr></table></figure>
<p><code>&lt;XXDuckEntity&gt;</code>被注释掉是因为真实使用场景会造成类型不匹配造成编译警告，所以caller使用起来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *json = <span class="string">@"&#123;\"name\": \"sunnyxx\", \"sex\": \"boy\", \"age\": 24&#125;"</span>;</span><br><span class="line"><span class="keyword">id</span>&lt;XXDuckEntity, XXUserEntity&gt; entity= XXDuckEntityCreateWithJSON(json);</span><br><span class="line"><span class="keyword">id</span>&lt;XXUserEntity&gt; copied = [entity <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %@, %@"</span>, copied.jsonString, copied.name, copied.age);</span><br></pre></td></tr></table></figure>
<p>这样重构的鸭子对象不仅隐藏了内部实现是个字典的事实，连它究竟是什么Class都隐藏了，但程序运行并无影响，骗一骗编译器罢了。不过这个思路的改变确引出另一个技术思路，那就是<code>依赖注入</code>。</p>
<hr>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p><code>Dependency Injection</code>，简称<code>DI</code>，其实在这个场景下叫<code>动态实现注入</code>更合适。它的思想是将一个“对象”分成三部分，<strong>protocol</strong>、<strong>proxy</strong>和<strong>implementation</strong>，试想有两个协议，他们定义了彼此间该如何发送message：<br><img src="http://ww1.sinaimg.cn/bmiddle/51530583jw1ejqir7ys6zj20lu04ywes.jpg" alt=""><br>运行时他们都是由proxy对象扮演：<br><img src="http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj0qchl2j20m009eq3k.jpg" alt=""><br>但DI Proxy并不能响应任何message，真正的实现是动态被“注入”到Proxy中的：<br><img src="http://ww3.sinaimg.cn/bmiddle/51530583jw1ejqj6c7uqrj20l60dw75f.jpg" alt=""><br>由于调用层只有协议没有类名，所以<code>Implement A</code>实现类并不依赖<code>Implement B</code>，就像贩毒团伙的两方只靠小弟来交易，完全不知道幕后大哥是谁，这就是所谓的“面向接口编程”吧。  </p>
<h2 id="Let’s-demo-it"><a href="#Let’s-demo-it" class="headerlink" title="Let’s demo it"></a>Let’s demo it</h2><p>重点在实现这个Proxy类，按照刚才重构Json Entity类的思路，头文件定义十分精简：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDIProxy.h</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">XXDIProxy</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)injectDependencyObject:(<span class="keyword">id</span>)object forProtocol:(Protocol *)protocol;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">id</span><span class="comment">/*&lt;XXDIProxy&gt;*/</span> XXDIProxyCreate();</span><br></pre></td></tr></table></figure>
<p>既然都叫Proxy了，再不使用<code>NSProxy</code>类都对不起它了。这个类使用一个字典来存储被注入的实现对象，以及与protocol的对应关系：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDIProxy.m 这是个私有类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXDIProxy</span> : <span class="title">NSProxy</span> &lt;<span class="title">XXDIProxy</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *implementations;</span><br><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实现<code>&lt;XXDIProxy&gt;</code>协议内容：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXDIProxy.m</span></span><br><span class="line">- (<span class="keyword">void</span>)injectDependencyObject:(<span class="keyword">id</span>)object forProtocol:(Protocol *)protocol</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(object &amp;&amp; protocol);</span><br><span class="line">    <span class="built_in">NSAssert</span>([object conformsToProtocol:protocol], <span class="string">@"object %@ does not conform to protocol: %@"</span>, object, protocol);</span><br><span class="line">    <span class="keyword">self</span>.implementations[<span class="built_in">NSStringFromProtocol</span>(protocol)] = object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤还是消息转发，非常简单，把收到的消息转发给能处理的implementation对象（如果用NSObject的<code>forwardingTargetForSelector</code>将更加简单）：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>.implementations.allValues) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([object respondsToSelector:sel]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [object methodSignatureForSelector:sel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>.implementations.allValues) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([object respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">            [invocation invokeWithTarget:object];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> forwardInvocation:invocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了Proxy类，下面是另外两个角色的测试代码，协议：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">XXGirlFriend</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)kiss;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实现类（汉字是可以正常编译运行的- -）：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 林志玲 : <span class="title">NSObject</span> &lt;<span class="title">XXGirlFriend</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> 凤姐 : <span class="title">NSObject</span> &lt;<span class="title">XXGirlFriend</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>测试代码：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">林志玲 *implementA = [林志玲 new];</span><br><span class="line">凤姐 *implementB = [凤姐 new];</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span>&lt;XXDIProxy, XXGirlFriend&gt; gf = XXDIProxyCreate();</span><br><span class="line">[gf injectDependencyObject:implementA forProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">XXGirlFriend</span>)];</span></span><br><span class="line">[gf kiss]; <span class="comment">// Log: 林志玲 kissed me</span></span><br><span class="line">[gf injectDependencyObject:implementB forProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">XXGirlFriend</span>)];</span></span><br><span class="line">[gf kiss]; <span class="comment">// Log: 凤姐 kissed me</span></span><br></pre></td></tr></table></figure>
<p>这个简单的demo就完成了。<br>这个demo的<code>源码</code>可以<a href="https://github.com/sunnyxx/XXDuckDemo" target="_blank" rel="external">-&gt;从这里下载&lt;-</a>，have fun.</p>
<hr>
<h1 id="我是后语"><a href="#我是后语" class="headerlink" title="我是后语"></a>我是后语</h1><p>现在有一个完整的依赖注入框架<a href="http://www.typhoonframework.org/" target="_blank" rel="external">typhoon</a>，感兴趣的可以把玩一下。<br>依赖注入不仅可以解耦依赖关系，也可以更好的Test和Mock，想测试某个对象只需要将实现对象注入成Test对象，想造假数据只需要将response对象替换成一个Mock对象，无需修改调用代码，天然不刺激~  </p>
<p><em>PS： 实际使用中可不要过度设计哦。。。</em></p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://c2.com/cgi/wiki?AlanKayOnMessaging" target="_blank" rel="external">http://c2.com/cgi/wiki?AlanKayOnMessaging</a><br><a href="http://www.typhoonframework.org/" target="_blank" rel="external">http://www.typhoonframework.org/</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/08/30/objc-pre-main/" class="prev">上一篇</a><a href="/2014/08/24/objc-duck/" class="next">下一篇</a></div><div data-thread-key="2014/08/26/objc-duck-advanced/" data-title="objc与鸭子对象（下）" data-url="http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>