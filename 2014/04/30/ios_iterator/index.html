<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ios中集合遍历方法的比较和技巧 · sunnyxx的技术博客</title><meta name="description" content="ios中集合遍历方法的比较和技巧 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">ios中集合遍历方法的比较和技巧</h1><div class="post-time">2014年4月30日</div><div class="post-content"><h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p>集合的遍历操作是开发中最常见的操作之一，从C语言经典的for循环到利用多核cpu的优势进行遍历，开发中ios有若干集合遍历方法，本文通过研究和测试比较了各个操作方法的效率和优略势，并总结几个使用集合遍历时的小技巧。</p>
<hr>
<h1 id="ios中常用的遍历运算方法"><a href="#ios中常用的遍历运算方法" class="headerlink" title="ios中常用的遍历运算方法"></a>ios中常用的遍历运算方法</h1><p>遍历的目的是获取集合中的某个对象或执行某个操作，所以能满足这个条件的方法都可以作为备选：  </p>
<ul>
<li>经典for循环</li>
<li>for in (NSFastEnumeration)，若不熟悉可以参考<a href="http://nshipster.com/enumerators/" target="_blank" rel="external">《nshipster介绍NSFastEnumeration的文章》</a></li>
<li>makeObjectsPerformSelector</li>
<li>kvc集合运算符</li>
<li>enumerateObjectsUsingBlock</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent)</li>
<li>dispatch_apply</li>
</ul>
<hr>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验条件"><a href="#实验条件" class="headerlink" title="实验条件"></a>实验条件</h2><p>测试类如下：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> number;</span><br><span class="line">- (<span class="keyword">void</span>)doSomethingSlow; <span class="comment">// sleep(0.01)</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实验从两个方面来评价：  </p>
<ol>
<li>分别使用有 100 个对象和 1000000 个对象的 NSArray，只取对象，不执行操作，测试遍历速度  </li>
<li>使用有 100 个对象的 NSArray 遍历执行<code>doSomethingSlow</code>方法，测试遍历中多任务运行速度</li>
</ol>
<p>实验使用<code>CFAbsoluteTimeGetCurrent()</code>记录时间戳来计算运行时间，单位秒。<br>运行在 iPhone5 真机（双核cpu）  </p>
<h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><p>100对象遍历操作：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">经典<span class="keyword">for</span>循环 - <span class="number">0.001355</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> (<span class="built_in">NSFastEnumeration</span>) - <span class="number">0.002308</span></span><br><span class="line">makeObjectsPerformSelector - <span class="number">0.001120</span></span><br><span class="line">kvc集合运算符(@sum.number) - <span class="number">0.004272</span></span><br><span class="line">enumerateObjectsUsingBlock - <span class="number">0.001145</span></span><br><span class="line">enumerateObjectsWithOptions(<span class="built_in">NSEnumerationConcurrent</span>) - <span class="number">0.001605</span></span><br><span class="line">dispatch_apply(Concurrent) - <span class="number">0.001380</span></span><br></pre></td></tr></table></figure>
<p>1000000对象遍历操作：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">经典<span class="keyword">for</span>循环 - <span class="number">1.246721</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> (<span class="built_in">NSFastEnumeration</span>) - <span class="number">0.025955</span></span><br><span class="line">makeObjectsPerformSelector - <span class="number">0.068234</span></span><br><span class="line">kvc集合运算符(@sum.number) - <span class="number">21.677246</span></span><br><span class="line">enumerateObjectsUsingBlock - <span class="number">0.586034</span></span><br><span class="line">enumerateObjectsWithOptions(<span class="built_in">NSEnumerationConcurrent</span>) - <span class="number">0.722548</span></span><br><span class="line">dispatch_apply(Concurrent) - <span class="number">0.607100</span></span><br></pre></td></tr></table></figure>
<p>100对象遍历执行一个很费时的操作：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">经典<span class="keyword">for</span>循环 - <span class="number">1.106567</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> (<span class="built_in">NSFastEnumeration</span>) - <span class="number">1.102643</span></span><br><span class="line">makeObjectsPerformSelector - <span class="number">1.103965</span></span><br><span class="line">kvc集合运算符(@sum.number) - N/A</span><br><span class="line">enumerateObjectsUsingBlock - <span class="number">1.104888</span></span><br><span class="line">enumerateObjectsWithOptions(<span class="built_in">NSEnumerationConcurrent</span>) - <span class="number">0.554670</span></span><br><span class="line">dispatch_apply(Concurrent) - <span class="number">0.554858</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="值得注意的"><a href="#值得注意的" class="headerlink" title="值得注意的"></a>值得注意的</h2><ul>
<li>对于集合中对象数很多的情况下，<code>for in (NSFastEnumeration)</code>的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）</li>
<li>使用<code>kvc集合运算符</code>运算很大规模的集合时，效率明显下降（100万的数组离谱的21秒多），同时占用了大量内存和cpu</li>
<li><code>enumerateObjectsWithOptions(NSEnumerationConcurrent)</code>和<code>dispatch_apply(Concurrent)</code>的遍历执行可以利用到多核cpu的优势（实验中在双核cpu上效率基本上x2）</li>
</ul>
<hr>
<h1 id="遍历实践Tips"><a href="#遍历实践Tips" class="headerlink" title="遍历实践Tips"></a>遍历实践Tips</h1><h2 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h2><p><code>NSArray</code>和<code>NSOrderedSet</code>都支持使用<code>reverseObjectEnumerator</code>倒序遍历，如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *strings = @[<span class="string">@"1"</span>, <span class="string">@"2"</span>, <span class="string">@"3"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> [strings reverseObjectEnumerator]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法只在循环第一次被调用，所以也不必担心循环每次计算的问题。  </p>
<p>同时，使用<code>enumerateObjectsWithOptions:NSEnumerationReverse</code>也可以实现倒序遍历：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsWithOptions:<span class="built_in">NSEnumerationReverse</span> usingBlock:^(Sark *sark, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    [sark doSomething];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="使用block同时遍历字典key，value"><a href="#使用block同时遍历字典key，value" class="headerlink" title="使用block同时遍历字典key，value"></a>使用block同时遍历字典key，value</h2><p>block版本的字典遍历可以同时取key和value（forin只能取key再手动取value），如：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"a"</span>: <span class="string">@"1"</span>, <span class="string">@"b"</span>: <span class="string">@"2"</span>&#125;;</span><br><span class="line">[dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"key: %@, value: %@"</span>, key, obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="对于耗时且顺序无关的遍历，使用并发版本"><a href="#对于耗时且顺序无关的遍历，使用并发版本" class="headerlink" title="对于耗时且顺序无关的遍历，使用并发版本"></a>对于耗时且顺序无关的遍历，使用并发版本</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsWithOptions:<span class="built_in">NSEnumerationConcurrent</span> usingBlock:^(Sark *sark, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    [sark doSomethingSlow];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>遍历执行block会分配在多核cpu上执行（底层很可能就是gcd的并发queue），对于耗时的任务来说是很值得这么做的，而且在以后cpu升级成更多核心后不用改代码也可以享受带来的好处。同时，对于遍历的外部是保持同步的（遍历都完成后才继续执行下一行），猜想内部大概是gcd的dispatch_group或者信号量控制。</p>
<h2 id="代码可读性和效率的权衡"><a href="#代码可读性和效率的权衡" class="headerlink" title="代码可读性和效率的权衡"></a>代码可读性和效率的权衡</h2><p>虽然说上面的测试结果表明，在集合内元素不多时，经典for循环的效率要比forin要高，但是从代码可读性上来看，就远不如forin看着更顺畅；同样的还有kvc的集合运算符，一些内置的操作以<code>keypath</code>的方式声明，相比自己用for循环实现，一行代码就能搞定，清楚明了，还省去了重复工作；在framework中增加了集合遍历的block支持后，对于需要index的遍历再也不需要经典for循环的写法了。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://nshipster.com/enumerators/" target="_blank" rel="external">http://nshipster.com/enumerators/</a><br><a href="http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html" target="_blank" rel="external">http://iosdevelopertips.com/objective-c/fast-enumeration-on-the-iphone.html</a>   </p>
<hr>
<p>原创文章，转载请注明源地址，<a href="http://blog.sunnyxx.com">blog.sunnyxx.com</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/07/01/ios_ib_bridge/" class="prev">上一篇</a><a href="/2014/04/22/objc_dig_nslog/" class="next">下一篇</a></div><div data-thread-key="2014/04/30/ios_iterator/" data-title="ios中集合遍历方法的比较和技巧" data-url="http://blog.sunnyxx.com/2014/04/30/ios_iterator/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>