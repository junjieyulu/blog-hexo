<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Reactive Cocoa Tutorial [1] = 神奇的Macros · sunnyxx的技术博客</title><meta name="description" content="Reactive Cocoa Tutorial [1] = 神奇的Macros - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Reactive Cocoa Tutorial [1] = 神奇的Macros</h1><div class="post-time">2014年3月6日</div><div class="post-content"><p>Reactive Cocoa Tutorial 系列，转载请注明该文源地址 – by sunnyxx</p>
<hr>
<h2 id="先说说RAC中必须要知道的宏："><a href="#先说说RAC中必须要知道的宏：" class="headerlink" title="先说说RAC中必须要知道的宏："></a>先说说RAC中必须要知道的宏：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(TARGET, [KEYPATH, [NIL_VALUE]])</span><br></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;</span><br><span class="line">RAC(self.outputLabel, text, @&quot;收到nil时就显示我&quot;) = self.inputTextField.rac_textSignal;</span><br></pre></td></tr></table></figure></p>
<p>　　这个宏是最常用的，<code>RAC()</code>总是出现在等号左边，等号右边是一个<code>RACSignal</code>，表示的意义是将一个对象的一个<code>属性</code>和一个<code>signal</code>绑定，signal每产生一个value（id类型），都会自动执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</span><br></pre></td></tr></table></figure>
<p>　　数字值会升级为<code>NSNumber *</code>，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　· RACObserve(TARGET, KEYPATH)</span><br></pre></td></tr></table></figure>
<p>　　作用是观察TARGET的KEYPATH属性，相当于<code>KVO</code>，产生一个<code>RACSignal</code></p>
<p>　　最常用的使用，和RAC宏绑定属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.outputLabel, text) = RACObserve(self.model, name);</span><br></pre></td></tr></table></figure></p>
<p>　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@weakify(Obj);</span><br><span class="line">@strongify(Obj);</span><br></pre></td></tr></table></figure>
<p>　　这对宏在 <code>RACEXTScope.h</code> 中定义，RACFramework好像没有默认引入，需要单独import</p>
<p>　　<strong>他们的作用主要是在block内部管理对self的引用</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>); <span class="comment">// 定义了一个__weak的self_weak_变量</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>, name) subscribeNext:^(<span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>); <span class="comment">// 局域定义了一个__strong的self指针指向self_weak</span></span><br><span class="line">    <span class="keyword">self</span>.outputLabel.text = name;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。</p>
<p>　　<strong>这两个宏一定成对出现，先weak再strong</strong></p>
<h2 id="除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。"><a href="#除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。" class="headerlink" title="除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。"></a>除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。</h2><p>　　举个高级点的栗子：</p>
<p>　　要干的一件事，<strong>计算一个可变参数列表的长度</strong>。</p>
<p>　　第一反应就是用参数列表的api，<code>va_start</code> <code>va_arg</code> <code>va_end</code>遍历一遍计算个和，但仔细想想，对于可变参数这个事，在<strong>编译前</strong>其实就已经确定了，代码里括号里有多少个参数一目了然。</p>
<p>　　RAC中<code>Racmetamarcos.h</code>中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define metamacro_argcount(...) \</span><br><span class="line">    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>
<p>这个宏由几个工具宏一层层展开，现在模拟一下展开过程：</p>
<p>假如我们要计算的如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = metamacro_argcount(a, b, c);</span><br></pre></td></tr></table></figure></p>
<p>于是乎<strong>第一层</strong>展开后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure></p>
<p>再看metamacro_at的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)</span><br><span class="line">// 下面是metamacro_concat做的事（简写一层）</span><br><span class="line">#define metamacro_concat_(A, B) A ## B</span><br></pre></td></tr></table></figure></p>
<p>于是乎<strong>第二层</strong>展开后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br></pre></td></tr></table></figure></p>
<p>再看metamacro_at20这个宏干的事儿：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)</span><br></pre></td></tr></table></figure></p>
<p>于是乎<strong>第三层</strong>展开后，相当于截断了前20个参数，留下剩下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = metamacro_head(3, 2, 1);</span><br></pre></td></tr></table></figure></p>
<p>这个metamacro_head：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)</span><br><span class="line">#define metamacro_head_(FIRST, ...) FIRST</span><br></pre></td></tr></table></figure></p>
<p>　　后面加个0，然后取参数列表第一个，于是乎：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = 3;</span><br></pre></td></tr></table></figure></p>
<p>　　<strong>大功告成。</strong></p>
<p>　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。</p>
<h2 id="除了上面，还有一个神奇的宏的使用："><a href="#除了上面，还有一个神奇的宏的使用：" class="headerlink" title="除了上面，还有一个神奇的宏的使用："></a>除了上面，还有一个神奇的宏的使用：</h2><p>　　当使用诸如<code>RAC(self, outputLabel)</code>或<code>RACObserve(self, name)</code>时，发现写完逗号之后，<strong>输入第二个property的时候会出现完全正确的代码提示</strong>！这相当神奇。<br><img src="http://images.cnitblog.com/blog/401798/201402/112147518936541.png" alt="自动代码提示"></p>
<p>探究一下，关键的关键是如下一个宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define keypath(...) \</span><br><span class="line">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))</span><br></pre></td></tr></table></figure></p>
<p>这个<code>metamacro_argcount</code>上面说过，是计算<strong>可变参数</strong>个数，所以<code>metamacro_if_eq</code>的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。</p>
<p>所以重点说一下keypath2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define keypath2(OBJ, PATH) \</span><br><span class="line">    (((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure></p>
<p>　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如”outputLabel.text”的字符串，所以这个宏的返回值应该是个字符串，可以简化成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define keypath2(OBJ, PATH) (???????, # PATH)</span><br></pre></td></tr></table></figure></p>
<p>先不管”??????”是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0, b = 0;</span><br><span class="line">a = 1, b = 2;</span><br><span class="line">int c = (a, b);</span><br></pre></td></tr></table></figure></p>
<p>这些都是<strong>逗号表达式</strong>的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。</p>
<p>去除warning的方法很简单，强转成void就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = ((void)a, b);</span><br></pre></td></tr></table></figure></p>
<p>再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((void)(NO &amp;&amp; ((void)OBJ.PATH, NO)), # PATH))</span><br></pre></td></tr></table></figure>
<p>对传入的第一个参数OBJ和第二个正要输入的PATH做了<code>点</code>操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。</p>
<p>　但至于为什么加入与<code>NO</code>做<code>&amp;&amp;</code>，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。</p>
<p>　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。</p>
<h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h2><p>RAC对宏的使用达到了很高的水平，还有诸如<code>RACTuplePack</code>，<code>RACTupleUnpack</code>的宏就不细说了，值得研究。</p>
<hr>
<p>PS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/03/06/rac_2_racstream/" class="prev">上一篇</a><a href="/2014/03/06/rac_0_overview/" class="next">下一篇</a></div><div data-thread-key="2014/03/06/rac_1_macros/" data-title="Reactive Cocoa Tutorial [1] = 神奇的Macros" data-url="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>