<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> objc kvo简单探索 · sunnyxx的技术博客</title><meta name="description" content="objc kvo简单探索 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">objc kvo简单探索</h1><div class="post-time">2014年3月9日</div><div class="post-content"><p>KVO(Key Value Observing)，是<code>观察者模式</code>在<code>Foundation</code>中的实现</p>
<h2 id="KVO的原理"><a href="#KVO的原理" class="headerlink" title="KVO的原理"></a>KVO的原理</h2><p>简而言之就是：</p>
<ol>
<li>当一个object有观察者时，动态创建这个object的类的子类</li>
<li>对于每个被观察的property，重写其<code>set</code>方法</li>
<li>在重写的<code>set</code>方法中调用<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code>通知观察者</li>
<li>当一个property没有观察者时，删除重写的方法</li>
<li>当没有observer观察任何一个property时，删除动态创建的子类</li>
</ol>
<p>空说无凭，简单验证下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sark *sark = [Sark new];</span><br><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line">[sark addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line">sark.name = <span class="string">@"萨萨萨"</span>;</span><br><span class="line">[sark removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br></pre></td></tr></table></figure>
<p>断住后分别使用<code>- class</code>和<code>object_getClass()</code>打出<code>sark</code>对象的Class和真实的Class   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line">(lldb) po sark.class</span><br><span class="line">Sark</span><br><span class="line">(lldb) po object_getClass(sark)</span><br><span class="line">Sark</span><br><span class="line"></span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line">(lldb) po sark.class</span><br><span class="line">Sark</span><br><span class="line">(lldb) po object_getClass(sark)</span><br><span class="line"><span class="built_in">NSKVONotifying_Sark</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br><span class="line">(lldb) po sark.class</span><br><span class="line">Sark</span><br><span class="line">(lldb) po object_getClass(sark)</span><br><span class="line">Sark</span><br></pre></td></tr></table></figure>
<p>上面的结果说明，在sark对象被观察时，framework使用<code>runtime</code>动态创建了一个Sark类的子类<code>NSKVONotifying_Sark</code><br>而且为了隐藏这个行为，NSKVONotifying_Sark重写了<code>- class</code>方法返回之前的类，就好像什么也没发生过一样<br>但是使用<code>object_getClass()</code>时就暴露了，因为这个方法返回的是这个对象的<code>isa</code>指针，<strong>这个指针指向的一定是个这个对象的类对象</strong>  </p>
<hr>
<p>然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展<code>NSObject+DLIntrospection</code>，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">DLIntrospection</span>)</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)classes;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)properties;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)instanceVariables;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)classMethods;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)instanceMethods;</span><br><span class="line">+ (<span class="built_in">NSArray</span> *)protocols;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)descriptionForProtocol:(Protocol *)proto;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)parentClassHierarchy;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后继续在刚才的断点处调试：   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class="line">&lt;__<span class="built_in">NSArrayI</span> <span class="number">0x8e9aa00</span>&gt;(</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="keyword">id</span>)arg0 ,</span><br><span class="line">- (<span class="keyword">void</span>).cxx_destruct,</span><br><span class="line">- (<span class="keyword">id</span>)name</span><br><span class="line">)</span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class="line">&lt;__<span class="built_in">NSArrayI</span> <span class="number">0x8d55870</span>&gt;(</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="keyword">id</span>)arg0 ,</span><br><span class="line">- (class)class,</span><br><span class="line">- (<span class="keyword">void</span>)dealloc,</span><br><span class="line">- (<span class="built_in">BOOL</span>)_isKVOA</span><br><span class="line">)</span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br><span class="line">(lldb) po [object_getClass(sark) instanceMethods]</span><br><span class="line">&lt;__<span class="built_in">NSArrayI</span> <span class="number">0x8e9cff0</span>&gt;(</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="keyword">id</span>)arg0 ,</span><br><span class="line">- (<span class="keyword">void</span>).cxx_destruct,</span><br><span class="line">- (<span class="keyword">id</span>)name</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>首先就有个扎眼的<code>- .cxx_destruct</code>冒出来，这货是个啥？详细的探究请参考我的<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">另一篇文章</a>。</p>
<p>大概就是说arc下这个方法在所有<code>dealloc</code>调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。<br>从上面breakpoint2的打印可以看出，动态类重写了4个方法：   </p>
<ol>
<li><code>- setName:</code>最主要的重写方法，set值时调用通知函数</li>
<li><code>- class</code>隐藏自己必备啊，返回原来类的class</li>
<li><code>- dealloc</code>做清理犯罪现场工作</li>
<li><code>- _isKVOA</code>这就是内部使用的标示了，判断这个类有没被KVO动态生成子类</li>
</ol>
<hr>
<p>接下来验证一下KVO重写set方法后是否调用了<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code><br>最直接的验证方法就是在Sark类中重写这两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>没问题。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/03/14/xcode_plugins/" class="prev">上一篇</a><a href="/2014/03/07/hexo_customize/" class="next">下一篇</a></div><div data-thread-key="2014/03/09/objc_kvo_secret/" data-title="objc kvo简单探索" data-url="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>