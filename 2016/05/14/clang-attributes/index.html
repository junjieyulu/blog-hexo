<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Clang Attributes 黑魔法小记 · sunnyxx的技术博客</title><meta name="description" content="Clang Attributes 黑魔法小记 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Clang Attributes 黑魔法小记</h1><div class="post-time">2016年5月14日</div><div class="post-content"><p>Clang Attributes 是 Clang 提供的一种<strong>源码注解</strong>，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 <code>NS_CLASS_AVAILABLE_IOS(9_0)</code> 就是 <code>__attribute__(availability(...))</code> 这个属性的简单写法。</p>
<p>常见属性的介绍，可以看 NSHipster 的<a href="http://nshipster.com/__attribute__/" target="_blank" rel="external">介绍文章</a> 和的 twitter 的<a href="https://blog.twitter.com/2014/attribute-directives-in-objective-c" target="_blank" rel="external">介绍文章</a>。本文还会介绍几个有意思的 <strong>“黑魔法”</strong> Attribute，说不定在某些场景下会起到意想不到的效果哦~</p>
<blockquote>
<p>以下测试都以 Xcode 7.3 ( Clang 3.8 ) 为准</p>
</blockquote>
<h2 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h2><p>使用这个属性可以定义一个 <code>Final Class</code>，也就是说，一个不可被继承的类，假设我们有个名叫 <code>Eunuch（太监）</code> 的类，但并不希望有人可以继承自它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Eunuch</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Child</span> : <span class="title">Eunuch</span> // 太监不能够有孩砸</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>只要在 @interface 前面加上 <code>objc_subclassing_restricted</code> 这个属性即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Eunuch</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Child</span> : <span class="title">Eunuch</span> // &lt;--- <span class="title">Compile</span> <span class="title">Error</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h2><p>aka: <code>NS_REQUIRES_SUPER</code>，标志子类继承这个方法时需要调用 <code>super</code>，否则给出编译警告：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)hailHydra __attribute__((objc_requires_super));</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">void</span>)hailHydra &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hail hydra!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span></span></span><br><span class="line">- (<span class="keyword">void</span>)hailHydra &#123;</span><br><span class="line">&#125; <span class="comment">// &lt;--- Warning missing [super hailHydra]</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h2><p>Objective-C 中的 <code>@(...)</code> 语法糖可以将基本数据类型 box 成 <code>NSNumber</code> 对象，假如想 box 一个 <code>struct</code> 类型或是 <code>union</code> 类型成 <code>NSValue</code> 对象，可以使用这个属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __attribute__((objc_boxable)) &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> x, y, width, height;</span><br><span class="line">&#125; XXRect;</span><br></pre></td></tr></table></figure>
<p>这样一来，<code>XXRect</code> 就具备被 box 的能力：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">NSValue</span> *value1 = @(rect1); <span class="comment">// &lt;--- Compile Error</span></span><br><span class="line">XXRect rect2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">NSValue</span> *value2 = @(rect2); <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h2><p>顾名思义，构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）<strong>load</strong> 和 <strong>unload</strong> 时被调用，可以理解为在 <code>main()</code> 函数调用前和 return 后执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> beforeMain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"beforeMain"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> afterMain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"afterMain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Console:</span></span><br><span class="line"><span class="comment">// "beforeMain" -&gt; "main" -&gt; "afterMain"</span></span><br></pre></td></tr></table></figure>
<p>constructor 和 <code>+load</code> 都是在 main 函数执行前调用，但 <code>+load</code> 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 <code>objc runtime</code> 去加载其中所有的类，每加载一个类时，它的 <code>+load</code> 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。</p>
<p>所以 constructor 是一个干坏事的绝佳时机：</p>
<ol>
<li>所有 Class 都已经加载完成</li>
<li>main 函数还未执行</li>
<li>无需像 +load 还得挂载在一个 Class 中</li>
</ol>
<p><code>FDStackView</code> 的 <a href="https://github.com/forkingdog/FDStackView/blob/master/FDStackView/FDStackView.m#L257" target="_blank" rel="external">FDStackViewPatchEntry</a> 方法便是使用的这个时机来实现偷天换日的伎俩。</p>
<blockquote>
<p>PS：若有多个 constructor 且想控制优先级的话，可以写成 <code>__attribute__((constructor(101)))</code>，里面的数字越小优先级越高，1 ~ 100 为系统保留。</p>
</blockquote>
<h2 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h2><p>这个属性只能用在 C 函数上，可以用来实现<strong>参数的静态检查</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> printValidAge(<span class="keyword">int</span> age)</span><br><span class="line">__attribute__((enable_if(age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">120</span>, <span class="string">"你丫火星人？"</span>))) &#123;</span><br><span class="line">    printf(<span class="string">"%d"</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它表示调用这个函数时必须满足 <code>age &gt; 0 &amp;&amp; age &lt; 120</code> 才被允许，于是乎：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printValidAge(<span class="number">26</span>); <span class="comment">// √</span></span><br><span class="line">printValidAge(<span class="number">150</span>); <span class="comment">// &lt;--- Compile Error</span></span><br><span class="line">printValidAge(<span class="number">-1</span>); <span class="comment">// &lt;--- Compile Error</span></span><br></pre></td></tr></table></figure>
<h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h2><p>声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 <code>@onExit</code>，关于这个 attribute，在之前的文章中有介绍，<a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/">传送门</a>。</p>
<h2 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h2><p>用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) <span class="function"><span class="keyword">void</span> <span class="title">logAnything</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) <span class="function"><span class="keyword">void</span> <span class="title">logAnything</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, @(number));</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) <span class="function"><span class="keyword">void</span> <span class="title">logAnything</span><span class="params">(CGRect rect)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Tests</span></span><br><span class="line">logAnything(@[@<span class="string">"1"</span>, @<span class="string">"2"</span>]);</span><br><span class="line">logAnything(<span class="number">233</span>);</span><br><span class="line">logAnything(CGRectMake(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h2 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h2><p>用于 <code>@interface</code> 或 <code>@protocol</code>，将类或协议的名字在编译时指定成另一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(<span class="string">"SarkGay"</span>)))</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([Sark class])); <span class="comment">// "SarkGay"</span></span><br></pre></td></tr></table></figure>
<p>所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(<span class="string">"40ea43d7629d01e4b8d6289a132482d0dd5df4fa"</span>)))</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecretClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 <code>objc_runtime_name</code>，岂不是最最精简版的代码混淆就完成了呢…</p>
<p>它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 <code>annotation</code> 的形式完成某些功能，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @singleton 包裹了 __attribute__((objc_runtime_name(...)))</span></span><br><span class="line"><span class="comment">// 将类名改名成 "SINGLETON_Sark_sharedInstance"</span></span><br><span class="line">@singleton(Sark, sharedInstance)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在运行时用 <code>__attribute__((constructor))</code> 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 <code>+ alloc</code>，<code>- init</code> 等方法替换，返回 <code>+ sharedInstance</code> 单例。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://llvm.org/releases/3.8.0/tools/clang/docs/AttributeReference.html" target="_blank" rel="external">http://llvm.org/releases/3.8.0/tools/clang/docs/AttributeReference.html</a><br><a href="http://clang-analyzer.llvm.org/annotations.html" target="_blank" rel="external">http://clang-analyzer.llvm.org/annotations.html</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/22/objc-class-extension-tips/" class="next">下一篇</a></div><div data-thread-key="2016/05/14/clang-attributes/" data-title="Clang Attributes 黑魔法小记" data-url="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>